<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo教程</title>
    <url>/posts/3555854685.html/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设计以以下为工具讲起</p>
<ul>
<li>PHP为开发语言</li>
<li>基于Laravel框架</li>
<li>MySQL为数据存储</li>
</ul>
<p>电商的可变性与孩子的心情一样，变化极快，所以在设计之处就要想好大部分的功能接入及开发，尽量减少重构次数。对老板来说节约成本，对程序员来说“珍惜生命”</p>
<h1 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h1><p>前期业务简单时，我们可以将数据表设计为下列的样子</p>
<table>
<thead>
<tr>
<th>TableName</th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td>member</td>
<td>用户表</td>
</tr>
<tr>
<td>member_address</td>
<td>收货地址表</td>
</tr>
<tr>
<td>member_card</td>
<td>银行卡表</td>
</tr>
<tr>
<td>member_cart</td>
<td>购物车表</td>
</tr>
<tr>
<td>member_cart_item</td>
<td>购物车商品表</td>
</tr>
<tr>
<td>member_collect_product</td>
<td>商品收藏表</td>
</tr>
<tr>
<td>member_collect_supplier</td>
<td>店铺收藏表</td>
</tr>
<tr>
<td>member_data</td>
<td>用户信息表</td>
</tr>
<tr>
<td>member_query_history</td>
<td>用户搜索历史表</td>
</tr>
<tr>
<td>member_wallet</td>
<td>用户账户表</td>
</tr>
<tr>
<td>member_withdrawal</td>
<td>用户提现表</td>
</tr>
</tbody></table>
<h2 id="用户表"><a href="#用户表" class="headerlink" title="用户表"></a>用户表</h2><p>考虑到多种登录方式，应在数据表中涉及到微信的openid,unionid,支付宝、QQ的用户token等，这些要在前期就涉及进去，因后期用户量大了之后加一个字段简直是噩梦,用户状态status也必不可少，比较人也是分好坏，其次就是创建时间，登录时间等，用户表与用户信息表绝逼是绑定关系，这就不多言了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `member` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `tel` bigint(20) DEFAULT NULL COMMENT &#x27;手机号码&#x27;,</span><br><span class="line">  `password` varchar(555) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;登录密码&#x27;,</span><br><span class="line">  `wx_token` varchar(125) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT &#x27;微信TOKEN&#x27;,</span><br><span class="line">  `im_token` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;用户融云token&#x27;,</span><br><span class="line">  `open_id` varchar(125) COLLATE utf8mb4_unicode_ci DEFAULT NULL,</span><br><span class="line">  `status` enum(&#x27;1&#x27;,&#x27;-1&#x27;) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;账号状态&#x27;,</span><br><span class="line">  `created_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  `updated_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `member_tel_unique` (`tel`),</span><br><span class="line">  UNIQUE KEY `member_wx_token_unique` (`wx_token`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=95 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbck3s?w=1148&h=946" alt="clipboard.png"></p>
<h2 id="收货地址表"><a href="#收货地址表" class="headerlink" title="收货地址表"></a>收货地址表</h2><p>收货地址与用户是一一相对的，在设计上增加需要的字段即可，例如 收货人、收货人手机号、城市、详细地址等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `member_address` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `member_id` int(11) NOT NULL COMMENT &#x27;用户编号&#x27;,</span><br><span class="line">  `nick_name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;收货人姓名&#x27;,</span><br><span class="line">  `tel` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;手机号码&#x27;,</span><br><span class="line">  `prov` int(11) DEFAULT NULL COMMENT &#x27;省&#x27;,</span><br><span class="line">  `city` int(11) NOT NULL COMMENT &#x27;市&#x27;,</span><br><span class="line">  `area` int(11) DEFAULT NULL COMMENT &#x27;区&#x27;,</span><br><span class="line">  `address` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;街道地址&#x27;,</span><br><span class="line">  `number` int(11) NOT NULL COMMENT &#x27;邮政编码&#x27;,</span><br><span class="line">  `default` enum(&#x27;0&#x27;,&#x27;1&#x27;) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;默认收货地址 1=&gt;默认&#x27;,</span><br><span class="line">  `deleted_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  `created_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  `updated_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=55 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbck3A?w=882&h=732" alt="clipboard.png"></p>
<h2 id="银行卡表"><a href="#银行卡表" class="headerlink" title="银行卡表"></a>银行卡表</h2><p>用于用户提现的业务等，大致将银行卡所需的信息记录即可，例如持卡人、卡号、归属银行等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `member_card` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `member_id` int(11) NOT NULL COMMENT &#x27;用户编码&#x27;,</span><br><span class="line">  `card_name` varchar(25) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;持卡人姓名&#x27;,</span><br><span class="line">  `card_number` varchar(25) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;银行卡号&#x27;,</span><br><span class="line">  `created_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  `updated_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `member_card_card_number_unique` (`card_number`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVbck3D?w=1132&h=564" alt="clipboard.png"></p>
<h2 id="购物车表"><a href="#购物车表" class="headerlink" title="购物车表"></a>购物车表</h2><p>为何单独建这个表，也是又一定原因的，正常只需要member_cart_item表即可，根据实际下线的业务场景，正常购物到超市需要拿一个购物车，但这个购物车并非属于你，你使用之后，需要归还，他人可继续使用，将购物车公开化，并不是将购物车商品公开化。业务场景比较窄，例如京东到家和京东商城一样（我只是举例，并不清楚他们怎么做的），购物车不通用，那如何区分呢，是应该在购物车上区分还是在购物车商品上区分？我想你已经清楚了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `member_cart` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `member_id` int(11) NOT NULL COMMENT &#x27;用户编码&#x27;,</span><br><span class="line">  `created_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  `updated_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `member_cart_member_id_unique` (`member_id`),</span><br><span class="line">  KEY `member_cart_member_id_index` (`member_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<h2 id="购物车商品表"><a href="#购物车商品表" class="headerlink" title="购物车商品表"></a>购物车商品表</h2><p>这块需要提的一点是 [并不是所有表的设计都是互相绑定,互相依赖的]，就例如购物车商品表，不仅仅将商品编码存储在内，还要将商品价格，商品的简介以及商品的规格(既SKU)存储，不能因卖家下架商品，而查询不到商品的存在，比较一切以用户为主，用户是上帝的原则，不能让商品悄悄的就消失了吧。所以在做购物车商品表查询时，切记不要使用join或者表关联查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `member_cart_item` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `cart_id` int(11) NOT NULL COMMENT &#x27;购物车编码&#x27;,</span><br><span class="line">  `product_desc` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;商品sku信息&#x27;,</span><br><span class="line">  `product_img` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;商品快照&#x27;,</span><br><span class="line">  `product_name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;商品名称&#x27;,</span><br><span class="line">  `price` decimal(8,2) NOT NULL DEFAULT &#x27;0.00&#x27; COMMENT &#x27;价格&#x27;,</span><br><span class="line">  `product_id` int(11) NOT NULL COMMENT &#x27;商品编码&#x27;,</span><br><span class="line">  `supplier_id` int(11) NOT NULL COMMENT &#x27;店铺编码&#x27;,</span><br><span class="line">  `sku_id` int(11) NOT NULL COMMENT &#x27;商品sku编码&#x27;,</span><br><span class="line">  `number` int(11) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;商品数量&#x27;,</span><br><span class="line">  `created_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  `updated_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `member_cart_item_cart_id_product_id_supplier_id_index` (`cart_id`,`product_id`,`supplier_id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<h2 id="用户搜索历史表"><a href="#用户搜索历史表" class="headerlink" title="用户搜索历史表"></a>用户搜索历史表</h2><p>用户搜索的记录是一定要有的，为了未来的数据分析，智能推荐做准备，毕竟现在是信息共享的时代嘛～</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `member_query_history` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `member_id` int(11) NOT NULL COMMENT &#x27;用户编码&#x27;,</span><br><span class="line">  `keyword` varchar(125) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT &#x27;关键字&#x27;,</span><br><span class="line">  `created_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  `updated_at` timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<h1 id="数据记录"><a href="#数据记录" class="headerlink" title="数据记录"></a>数据记录</h1><p>有很多场景，都要将标题呀，内容呀直接存储，类似与收藏的店铺和商品，无论卖家怎么做，用户购物车，订单不能动，这是基准。</p>
]]></content>
  </entry>
  <entry>
    <title>MAC&amp;IP</title>
    <url>/posts/2552668625.html/</url>
    <content><![CDATA[<h1 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h1><p>每一个网卡都有一个6字节(48bit)的MAC地址(Media Access Control Address)</p>
<p>全球唯一，固化在了网卡的ROM中，由IEEE802标准规定</p>
<p>前3字节:OUT (Organizationally Unique Identifier)，组织唯一标识符由IEEE的注册管理机构分配给厂商</p>
<p>后3字节：网络接口标识符 由厂商自行分配 </p>
<p><img src="/posts/2552668625.html/1628876264485-e52cf54e-7c16-4293-8146-0d18b8d8fc8d.png" alt="image.png"></p>
<h3 id="MAC地址的表示格式"><a href="#MAC地址的表示格式" class="headerlink" title="MAC地址的表示格式"></a>MAC地址的表示格式</h3><table>
<thead>
<tr>
<th>Windows</th>
<th>40-55-82-0A-8C-6D</th>
</tr>
</thead>
<tbody><tr>
<td>Linux、Android、Mac、iOS</td>
<td>40:55:82:0A:8C:6D</td>
</tr>
<tr>
<td>Packet Tracer</td>
<td>4055.820A.8C6D</td>
</tr>
</tbody></table>
<p>当48位全为1时，代表广播地址 FF-FF-FF-FF-FF-FF</p>
<h3 id="MAC地址操作"><a href="#MAC地址操作" class="headerlink" title="MAC地址操作"></a>MAC地址操作</h3><p>查看MAC地址：ipconfig/all</p>
<p>修改MAC地址：更改适配器选项-属性-配置-高级    网络地址；填写的时候需要把减号（-）去掉；有时可以修改MAC地址蹭网</p>
<p><img src="/posts/2552668625.html/1628928585801-c3d1e8c5-d4dd-40d6-9646-252fb7c3ade3.png" alt="image.png"></p>
<h3 id="MAC地址的获取"><a href="#MAC地址的获取" class="headerlink" title="MAC地址的获取"></a>MAC地址的获取</h3><p>当不知道对方主机的MAC地址时，可以通过发送ARP广播获取对方的MAC地址；获取成功后，会缓存IP地址、MAC地址的映射信息，俗称：ARP缓存；通过ARP广播获取的MAC地址，属于动态（dynamic）缓存；存储时间比较短（默认是2分钟），过期了就自动删除；</p>
<p>相关命令 </p>
<p>arp -a [主机地址]：查询ARP缓存 </p>
<p>arp -d [主机地址]：删除ARP缓存 </p>
<p>arp -s 主机地址 MAC地址：增加一条缓存信息（这是静态缓存，存储时间较久，不同系统的存储时间不同）</p>
<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>地址解析协议</p>
<p>通过IP地址来获取MAC地址</p>
<h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>逆地址解析协议</p>
<p>使用与ARP相同的报头结构；作用与ARP相反，用于将MAC地址转换为IP地址；后来被BOOTP、DHCP所取代 </p>
<h1 id="IPMP"><a href="#IPMP" class="headerlink" title="IPMP"></a>IPMP</h1><p>互联网控制消息协议</p>
<p>IPv4中的ICMP被称作ICMPv4，IPv6中的ICMP则被称作ICMPv6；通常用于返回错误信息，比如TTL值过期、目的不可达；ICMP的错误消息总是包括了源数据并返回给发送者</p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p> IP地址（Internet Protocol Address）：互联网上的每一个主机都有一个IP地址 最初是IPv4版本，32bit（4字节），2019年11月25日，全球的IP地址已经用完 后面推出了IPv6版本，128bit（16字节）</p>
<p><img src="/posts/2552668625.html/1628929142466-418de7a2-5dbc-4082-943f-77f5dce10a4d.png" alt="image.png"></p>
<h2 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h2><p>IP地址由2部分组成：网络标识（网络ID）、主机标识（主机ID） 通过子网掩码（subnet mask）可以得知网络ID 、主机ID</p>
<p>主机所在的网段 = 子网掩码 &amp; IP地址 网段其实 </p>
<p>计算机和其他计算机通信前，会先判断目标主机和自己是否在同一网段；同一网段：不需要由路由器进行转发；不同网段：交由路由器进行转发</p>
<h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><p>A类地址：默认子网掩码是255.0.0.0 </p>
<table>
<thead>
<tr>
<th>8bit</th>
<th>24bit</th>
</tr>
</thead>
<tbody><tr>
<td>网络ID 0开头</td>
<td>主机ID</td>
</tr>
</tbody></table>
<p>B类地址：默认子网掩码是255.255.0.0 </p>
<table>
<thead>
<tr>
<th>16bit</th>
<th>16bit</th>
</tr>
</thead>
<tbody><tr>
<td>网络ID 10开头</td>
<td>主机ID</td>
</tr>
</tbody></table>
<p>C类地址：默认子网掩码是255.255.255.0 </p>
<table>
<thead>
<tr>
<th>16bit</th>
<th>16bit</th>
</tr>
</thead>
<tbody><tr>
<td>网络ID 10开头</td>
<td>主机ID</td>
</tr>
</tbody></table>
<p>D类地址：以1110开头，多播地址 </p>
<p>E类地址：以1111开头，保留为今后使用 </p>
<p>只有A\B\C类地址才能分配给主机 </p>
<p>主机ID为全0，表示主机所在的网段 </p>
<p>主机ID为全1，表示主机所在网段的全部主机（广播） </p>
<p>可以尝试用ping给某个网段的全部主机发数据 </p>
<h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p><img src="/posts/2552668625.html/1628933103811-38e98b7d-805e-48bd-b783-300ced7d1ed9.png" alt="image.png"></p>
<p><strong>网络ID：</strong>0不能用，127作为保留网段。其中127.0.0.1是本地环回地址（Loopback），代表本机地址；可以分配给主机的 第1部分的取值范围是：1~126 </p>
<p><strong>主机ID：</strong> 第2、3、4部分的取值范围是：0~255；每个A类网络能容纳的最大主机数是：256 * 256 * 256 – 2 = 2的24次方 – 2 = 16777214</p>
<h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p><img src="/posts/2552668625.html/1628933282666-cea50444-d13d-441d-b823-8fc97364659c.png" alt="image.png"></p>
<p><strong>网络ID：</strong> 可以分配给主机的；第1部分的取值范围是：128<del>191；第2部分的取值范围是：0</del>255 </p>
<p><strong>主机ID：</strong> 第3、4部分的取值范围是：0~255；每个B类网络能容纳的最大主机数是：256 * 256 – 2 = 2的16次方 – 2 = 65534</p>
<p><img src="/posts/2552668625.html/1628933369115-31484f23-5a6b-47b1-9652-99bd5aa06134.png" alt="image.png"></p>
<p><strong>网络ID：</strong> 可以分配给主机的；第1部分的取值范围是：192<del>223；第2、3部分的取值范围是：0</del>255 </p>
<p><strong>主机ID：</strong> 第4部分的取值范围是：0~255；每个C类网络能容纳的最大主机数是：256 – 2 = 254</p>
<h3 id="D类地址，E类地址"><a href="#D类地址，E类地址" class="headerlink" title="D类地址，E类地址"></a>D类地址，E类地址</h3><p> D类地址：没有子网掩码，用于多播（组播）地址；第1部分取值范围是：224~239</p>
<p><img src="/posts/2552668625.html/1628933999648-320c2d36-6d3f-4756-9a88-5fa4ba961c18.png" alt="image.png"></p>
<p>E类地址：保留为今后使用；第1部分取值范围是：240~255 </p>
<p><img src="/posts/2552668625.html/1628934019841-fd1a175f-2b24-4a27-8231-1b8d5dbf3929.png" alt="image.png">  </p>
<h1 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h1><h2 id="子网掩码的CIDR表示方法"><a href="#子网掩码的CIDR表示方法" class="headerlink" title="子网掩码的CIDR表示方法"></a>子网掩码的CIDR表示方法</h2><p>CIDR（Classless Inter-Domain Routing）：无类别域间路由</p>
<p>子网掩码的CIDR表示方法 </p>
<p>192.168.1.100/24，代表子网掩码有24个1，也就是255.255.255.0 </p>
<p>123.210.100.200/16，代表子网掩码有16个1，也就是255.255.0.0</p>
<h2 id="为什么要进行子网划分"><a href="#为什么要进行子网划分" class="headerlink" title="为什么要进行子网划分"></a>为什么要进行子网划分</h2><p>如果需要让200台主机在同一个网段内，可以分配一个C类网段，比如192.168.1.0/24 </p>
<p>共254个可用IP地址：192.168.1.1~192.168.1.254 </p>
<p>多出54个空闲的IP地址，这种情况并不算浪费资源</p>
<p>如果需要让500台主机在同一个网段内，那就分配一个B类网段，比如191.100.0.0/16 </p>
<p>共65534个可用IP地址：191.100.0.1~191.100.255.254 </p>
<p>多出65034个空闲的IP地址，这种情况属于极大的浪费资源</p>
<p>如何尽量避免浪费IP地址资源？ </p>
<p>合理进行子网划分</p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p>子网划分：借用主机位作子网位，划分出多个子网 </p>
<p>可用分为 等长子网划分：将一个网段等分成多个子网，每个子网的可用IP地址数量是一样的 </p>
<p>变长子网划分：每个子网的可用IP地址数量可以是不一样的  </p>
<p>子网划分器：<a href="http://www.ab126.com/web/3552.html">http://www.ab126.com/web/3552.html</a>  </p>
<p>子网划分的步骤 </p>
<p>确定子网的子网掩码长度 </p>
<p>确定子网中第1个、最后1个主机可用的IP地址</p>
<h4 id="等长子网划分——等分成2个子网"><a href="#等长子网划分——等分成2个子网" class="headerlink" title="等长子网划分——等分成2个子网"></a>等长子网划分——等分成2个子网</h4><p><img src="/posts/2552668625.html/1628959922263-f20adfd9-9b71-4fc7-9f82-ed75eb4e152d.png" alt="image.png"></p>
<p>A子网 </p>
<p>子网掩码：255.255.255.128/25 </p>
<p>主机可用IP地址：192.168.0.1~192.168.0.126</p>
<p>B子网 </p>
<p>子网掩码：255.255.255.128/25 </p>
<p>主机可用IP地址：192.168.0.129~192.168.0.254</p>
<h4 id="等长子网划分——等分成4个子网"><a href="#等长子网划分——等分成4个子网" class="headerlink" title="等长子网划分——等分成4个子网"></a>等长子网划分——等分成4个子网</h4><p><img src="/posts/2552668625.html/1628959975821-e58c53ed-8028-4c7c-8637-774caa748945.png" alt="image.png"></p>
<p>4个子网的子网掩码都是：255.255.255.192/26</p>
<p>A子网的主机可用IP地址 192.168.0.1~192.168.0.62</p>
<p>B子网的主机可用IP地址 192.168.0.65~192.168.0.126</p>
<p>C子网的主机可用IP地址 192.168.0.129~192.168.0.190</p>
<p>D子网的主机可用IP地址 192.168.0.193~192.168.0.254</p>
<h5 id="等长子网划分——等分成4个子网的广播地址"><a href="#等长子网划分——等分成4个子网的广播地址" class="headerlink" title="等长子网划分——等分成4个子网的广播地址"></a>等长子网划分——等分成4个子网的广播地址</h5><p><img src="/posts/2552668625.html/1628960056727-14d7fee9-be1f-488f-ab57-86edff40de00.png" alt="image.png"></p>
<h4 id="等长子网划分——等分成8个子网"><a href="#等长子网划分——等分成8个子网" class="headerlink" title="等长子网划分——等分成8个子网"></a>等长子网划分——等分成8个子网</h4><p><img src="/posts/2552668625.html/1628960075918-62876a3a-2897-4e04-84b4-2ae0068ba9d5.png" alt="image.png"></p>
<p>4个子网的子网掩码都是：255.255.255.224/27</p>
<p>A子网：192.168.0.1~192.168.0.30</p>
<p>B子网：192.168.0.33~192.168.0.62</p>
<p>C子网：192.168.0.65~192.168.0.94</p>
<p>D子网：192.168.0.97~192.168.0.126</p>
<p>E子网：192.168.0.129~192.168.0.158</p>
<p>F子网：192.168.0.161~192.168.0.190</p>
<p>G子网：192.168.0.193~192.168.0.222</p>
<p>H子网：192.168.0.225~192.168.0.254 </p>
<h4 id="等长子网划分——B类子网划分"><a href="#等长子网划分——B类子网划分" class="headerlink" title="等长子网划分——B类子网划分"></a>等长子网划分——B类子网划分</h4><p><img src="/posts/2552668625.html/1628960187434-9244e108-5b90-446d-83ee-115ae1746f90.png" alt="image.png"></p>
<h4 id="等长子网划分——A类子网划分"><a href="#等长子网划分——A类子网划分" class="headerlink" title="等长子网划分——A类子网划分"></a>等长子网划分——A类子网划分</h4><p><img src="/posts/2552668625.html/1628960203601-9dc86c96-e248-42a8-9924-047913d662c4.png" alt="image.png"></p>
<h4 id="变长子网划分"><a href="#变长子网划分" class="headerlink" title="变长子网划分"></a>变长子网划分</h4><p>如果一个子网地址块的长度是原网段的(1/2)^n，那么 子网的子网掩码，就是在原网段的子网掩码基础上增加n个1 不等长的子网，它们的子网掩码也不同 </p>
<p><img src="/posts/2552668625.html/1628960240353-771952d9-b8c5-496b-9a18-c1cb4ac45fd0.png" alt="image.png"></p>
<p>假设上图是对192.168.0.0/24进行变长子网划分 </p>
<p>C网段：子网掩码是255.255.255.128/25 </p>
<p>B网段：子网掩码是255.255.255.192/26 </p>
<p>A网段：子网掩码是255.255.255.224/27 </p>
<p>D网段：子网掩码是255.255.255.252/30 </p>
<p>E网段：子网掩码是255.255.255.252/30</p>
<h1 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h1><p>跟子网反过来，它是将多个连续的网段合并成一个更大的网段 </p>
<p>需求：原本有200台计算机使用192.168.0.0/24网段，现在希望增加200台设备到同一个网段 </p>
<p>200台在192.168.0.0/24网段，200台在192.168.1.0/24网段 </p>
<p>合并192.168.0.0/24、192.168.1.0/24为一个网段：192.168.0.0/23（子网掩码往左移动1位）</p>
<p><img src="/posts/2552668625.html/1629048064654-179248c1-cc18-41cf-bf6d-caf4a8f2e937.png" alt="image.png"></p>
<h2 id="合并网段"><a href="#合并网段" class="headerlink" title="合并网段"></a>合并网段</h2><p>子网掩码向左移动2位，可以合并4个网段 </p>
<p><img src="/posts/2552668625.html/1629048251260-a4f6a470-d868-4c9a-8268-ad864449a47e.png" alt="image.png"></p>
<p>将192.168.0.0/24、192.168.1.0/24、192.168.2.0/24、192.168.3.0/24合并为192.168.0.0/22网段 </p>
<h3 id="合并网段的规律"><a href="#合并网段的规律" class="headerlink" title="合并网段的规律"></a>合并网段的规律</h3><p>假设n是2的k次幂（k≥1） </p>
<p>子网掩码左移k位能够将能够合并n个网段</p>
<p><img src="/posts/2552668625.html/1629048315876-b4bbcfc2-e1af-4653-8056-8047e5382789.png" alt="image.png"></p>
<p>假设n是2的k次幂（k≥1） </p>
<p>如果第一个网段的网络号能被n整除，那么由它开始连续的n个网段，能通过左移k位子网掩码进行合并</p>
<p>比如 </p>
<p>第一个网段的网络号以二进制0结尾，那么由它开始连续的2个网段，能通过左移1位子网掩码进行合并 </p>
<p>第一个网段的网络号以二进制00结尾，那么由它开始连续的4个网段，能通过左移2位子网掩码进行合并 </p>
<p>第一个网段的网络号以二进制000结尾，那么由它开始连续的8个网段，能通过左移3位子网掩码进行合并</p>
<h3 id="判断一个网段是子网还是超网"><a href="#判断一个网段是子网还是超网" class="headerlink" title="判断一个网段是子网还是超网"></a>判断一个网段是子网还是超网</h3><p>首先 </p>
<p>看看该网段的类型，是A类网络、B类网络、C类网络？ </p>
<p>默认情况下，A类子网掩码的位数是8，B类子网掩码的位数是16，C类子网掩码的位数是24</p>
<p>然后 </p>
<p>如果该网段的子网掩码位数比默认子网掩码多，就是子网 </p>
<p>如果该网段的子网掩码位数比默认子网掩码少，则是超网</p>
<p>比如 </p>
<p>25.100.0.0/16是一个A类子网 </p>
<p>200.100.0.0/16是一个C类超网</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>两台电脑能否正常通信</p>
<p><img src="/posts/2552668625.html/1629046599763-c637daad-1aa0-4781-b04d-316040bcca8c.png" alt="image.png"></p>
<p><img src alt="img"><img src alt="img"><img src="/posts/2552668625.html/1629047924552-c786958b-cb1b-4c98-b619-8f4c4660a8f6.jpeg" alt="QQ图片20210816011805.jpg"></p>
<p>计算机1可以给计算机0发消息，但是计算机0不能给计算机1发消息</p>
<p>所以不能相互通信</p>
<p>192.168.0.255/23这个IP地址，可以分配给计算机使用么？ </p>
<p><img src="/posts/2552668625.html/1629048099846-fb3191a3-d25d-4085-a07f-130d1b7ab028.png" alt="image.png"></p>
<p>主机部分不是全为1，所以可以使用</p>
<p>下面的2个网段，能通过子网掩码向左移动1位进行合并么</p>
<p><img src="/posts/2552668625.html/1629048279730-4f285b59-b583-435e-9b3c-cfbb0caded0a.png" alt="image.png"></p>
<p>不可以</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>MAC&amp;IP</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/posts/2819424305.html/</url>
    <content><![CDATA[<p>动态规划，简称DP；在面试中的算法题中也很常见，是求最优化解的一种常用思路，之前也是一直困扰我的一个问题。</p>
<p>通常的使用套路（一步一步优化） </p>
<p>① 暴力递归（自顶向下，出现了重叠子问题） </p>
<p>② 记忆化搜索（自顶向下） </p>
<p>③ 递推（自底向上）</p>
<p><strong>动态规划常用步骤：</strong></p>
<p>动态规划中的“动态”可以理解为是“会变化的状态”  </p>
<p>① 定义状态（状态是原问题、子问题的解） 比如定义 dp(i) 的含义  </p>
<p>② 设置初始状态（边界） 比如设置 dp(0) 的值  </p>
<p>③ 确定状态转移方程 比如确定 dp(i) 和 dp(i – 1) 的关系 </p>
<p><strong>含义：</strong></p>
<p>① 将复杂的原问题拆解成若干个简单的子问题 </p>
<p>② 每个子问题仅仅解决1次，并保存它们的解 </p>
<p>③ 最后推导出原问题的解</p>
<p>可以用动态规划来解决的问题，通常具备2个特点 最优子结构（最优化原理）：</p>
<p>通过求解子问题的最优解，可以获得原问题的最优解；无后效性；某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响（未来与过去无关）；在推导后面阶段的状态时，只关心前面阶段的具体状态值，不关心这个状态是怎么一步步推导出来的</p>
<h1 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h1><p><img src="/posts/2819424305.html/1629520772727-063d24fb-a5b1-48e9-b965-e7a72c4dede2.png" alt="image.png"></p>
<p>从起点（0, 0）走到终点（4, 4）一共有多少种走法？只能向右、向下走  </p>
<p>假设 dp(i, j) 是从（0, 0）走到（i, j）的走法 </p>
<p>dp(i, 0) = dp(0, j) = 1 </p>
<p>dp(i, j) = dp(i, j – 1) + dp(i – 1, j)</p>
<p> 无后效性 </p>
<p>推导 dp(i, j) 时只需要用到 dp(i, j – 1)、dp(i – 1, j) 的值 </p>
<p>不需要关心 dp(i, j – 1)、dp(i – 1, j) 的值是怎么求出来的</p>
<p>如果可以向左、向右、向上、向下走，并且同一个格子不能走 2 次  </p>
<p>有后效性 </p>
<p>dp(i, j) 下一步要怎么走，还要关心上一步是怎么来的 </p>
<p>也就是还要关心 dp(i, j – 1)、dp(i – 1, j) 是怎么来的？</p>
<h1 id="找零钱"><a href="#找零钱" class="headerlink" title="找零钱"></a>找零钱</h1><p>在贪心算法那一张中我们也讲到了这一题，但是我们当时只用了贪心算法，在这道题中并不能求出最优解</p>
<p>[贪心](<a href="https://blog.ghl.asia/posts/3209966166.html/">浅谈贪心算法 | GHL-Blog</a>)</p>
<p>今天我们利用动态规划来解决这道问题。</p>
<p>问题：</p>
<p>假设有25分、20分、5分、1分的硬币，现要找给客户41分的零钱，如何办到硬币个数最少？ </p>
<p>假设 dp(n) 是凑到 n 分需要的最少硬币个数 </p>
<p>如果第 1 次选择了 25 分的硬币，那么 dp(n) = dp(n – 25) + 1 </p>
<p>如果第 1 次选择了 20 分的硬币，那么 dp(n) = dp(n – 20) + 1 </p>
<p>如果第 1 次选择了 5 分的硬币，那么 dp(n) = dp(n – 5) + 1 </p>
<p>如果第 1 次选择了 1 分的硬币，那么 dp(n) = dp(n – 1) + 1 </p>
<p>所以 dp(n) = min { dp(n – 25), dp(n – 20), dp(n – 5), dp(n – 1) } + 1 </p>
<h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int coins1(int n) &#123;</span><br><span class="line">    if (n &lt; 1) return Integer.MAX_VALUE;</span><br><span class="line">    if (n == 25 || n == 20 || n == 5 || n == 1) return 1;</span><br><span class="line">    int min1 = Math.min(coins1(n - 25), coins1(n - 20));</span><br><span class="line">    int min2 = Math.min(coins1(n - 5), coins1(n - 1));</span><br><span class="line">    return Math.min(min1, min2) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自顶向下的调用，出现了重叠子问题</p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int coins2(int n) &#123;</span><br><span class="line">    if (n &lt; 1) return -1;</span><br><span class="line">    int[] dp = new int[n + 1];</span><br><span class="line">    int[] faces = &#123;1, 5, 20, 25&#125;;</span><br><span class="line">    for (int face : faces) &#123;</span><br><span class="line">        if (n &lt; face) break;</span><br><span class="line">        dp[face] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return coins2(n, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int coins2(int n, int[] dp) &#123;</span><br><span class="line">    if (n &lt; 1) return Integer.MAX_VALUE;</span><br><span class="line">    if (dp[n] == 0) &#123;</span><br><span class="line">        int min1 = Math.min(coins2(n - 25, dp), coins2(n - 20, dp));</span><br><span class="line">        int min2 = Math.min(coins2(n - 5, dp), coins2(n - 1, dp));</span><br><span class="line">        dp[n] = Math.min(min1, min2) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自顶向下的调用</p>
<p>为什么我们要用数组来存储对应的值呢？是不是有人想用哈希才存储值？那么问题来了，如我们去了解一下哈希表的底层，看一下哈希的实现，我们会发现，哈希的底层实现就是用数组来完成的，但是为了有更快的查找速度，在哈希表中，我们开辟的数组空间可能有很多都没有用上。所有我们使用数组会更加的减少内存的浪费。</p>
<h2 id="递推实现"><a href="#递推实现" class="headerlink" title="递推实现"></a>递推实现</h2><p>这种方法没有使用递归的方式</p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int coins3(int n) &#123;</span><br><span class="line">        if (n &lt; 1) return -1;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int min = Integer.MAX_VALUE;</span><br><span class="line">            if (i &gt;= 1)</span><br><span class="line">            &#123;min = Math.min(dp[i-1],min);&#125;</span><br><span class="line">            if (i &gt;= 5)</span><br><span class="line">            &#123;min = Math.min(dp[i - 5], min);&#125;</span><br><span class="line">            if (i &gt;= 20)</span><br><span class="line">            &#123;min = Math.min(dp[i - 20], min);&#125;</span><br><span class="line">            if (i &gt;= 25)</span><br><span class="line">            &#123;min = Math.min(dp[i - 25], min);&#125;</span><br><span class="line">            dp[i] = min + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它是从较小的值开始计算，如果n为41，那我们就从1开始计算，根据代码所示，在四之前我们都是用价值为1的硬币，当达到五之后我们用价值为5的硬币，……</p>
<p><img src="/posts/2819424305.html/1629553737321-76a0adb0-6b2a-4927-b6f4-d198a5a30445.jpeg" alt="QQ图片20210821214831.jpg"></p>
<p>整个dp数组存储着之前每个值所需的硬币数，每次寻找都是根据之前最少的硬币数，再加上现在所要的那一枚，</p>
<p>根据硬币所给的值，划分成不规则的分组。</p>
<h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><p>现在我们解决了找零钱的问题，但是我们做的是零钱地固定值，面试的时候面试官出的题不可能是和现在一的一样吧，就算代码上的数能改，要是每次给你的数都不一样呢？那咋办，哪能每次都改一下吗？那是不可能的，所以我们需要一个通解，但这不是让大家被代码，而是对这种类型题的更深层次理解。</p>
<p>第一件事就是根据上面的代码，我们要怎么才能知道我们每次凑齐的是哪些硬币</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    static int coins4(int n) &#123;</span><br><span class="line">        if (n &lt; 1) return -1;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        // faces[i]是凑够i分时最后那枚硬币的面值</span><br><span class="line">        int[] faces = new int[dp.length];</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            int min = dp[i - 1];</span><br><span class="line">            faces[i] = 1;</span><br><span class="line"></span><br><span class="line">            if (i &gt;= 5 &amp;&amp; dp[i - 5] &lt; min) &#123;</span><br><span class="line">                min = dp[i - 5];</span><br><span class="line">                faces[i] = 5;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt;= 20 &amp;&amp; dp[i - 20] &lt; min) &#123;</span><br><span class="line">                min = dp[i - 20];</span><br><span class="line">                faces[i] = 20;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt;= 25 &amp;&amp; dp[i - 25] &lt; min) &#123;</span><br><span class="line">                min = dp[i - 25];</span><br><span class="line">                faces[i] = 25;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min + 1;</span><br><span class="line">            print(faces, i);</span><br><span class="line">        &#125;</span><br><span class="line">//      print(faces, n);</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void print(int[] faces, int n) &#123;</span><br><span class="line">        System.out.print(&quot;[&quot; + n + &quot;] = &quot;);</span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            System.out.print(faces[n] + &quot; &quot;);</span><br><span class="line">            n -= faces[n];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们利用一个faces数组来记录最后一个添加硬币的值，之后我们不断向上推导，我们就知道了它是由哪些硬币组成的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int coins0(int n, int[] faces) &#123;</span><br><span class="line">    if (n &lt; 1 || faces == null || faces.length == 0) return -1;</span><br><span class="line">    int[] dp = new int[n + 1];</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        int min = Integer.MAX_VALUE;</span><br><span class="line">        for (int face : faces) &#123;</span><br><span class="line">            if (i &lt; face) continue;</span><br><span class="line">            min=Math.min(dp[i-face],min );</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]=min+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用数组来存贮硬币的面值，利用for循环来进行我们之前的判断</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/posts/3907716225.html/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</p>
<p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9</p>
<p>输出: 4</p>
<p>解释: 9 出现在 nums 中并且下标为 4</p>
<p>示例 2:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 2</p>
<p>输出: -1</p>
<p>解释: 2 不存在 nums 中因此返回 -1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int life=0,right=nums.length-1;</span><br><span class="line">        int p;</span><br><span class="line">        while (life&lt;=right)&#123;</span><br><span class="line">            p=life+(right-life)/2;</span><br><span class="line">            if(nums[p]==target) return p;</span><br><span class="line">            if(nums[p]&lt;target) life=p+1;</span><br><span class="line">            else right=p-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分查找是一种基于比较目标值和数组中间元素的教科书式算法。</p>
<ul>
<li>如果目标值等于中间元素，则找到目标值。</li>
<li>如果目标值较小，继续在左侧搜索。</li>
<li>如果目标值较大，则继续在右侧搜索。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1834295/1625567991316-308e35ad-d3bc-4192-a91e-4cc9569111ee.jpeg" alt="image"></p>
<h1 id="第一个错误版本"><a href="#第一个错误版本" class="headerlink" title="第一个错误版本"></a>第一个错误版本</h1><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例 1：</p>
<p>输入：n = 5, bad = 4</p>
<p>输出：4</p>
<p>解释：</p>
<p>调用 isBadVersion(3) -&gt; false</p>
<p>调用 isBadVersion(5) -&gt; true</p>
<p>调用 isBadVersion(4) -&gt; true</p>
<p>所以，4 是第一个错误的版本。</p>
<p>示例 2：</p>
<p>输入：n = 1, bad = 1</p>
<p>输出：1</p>
<p>通过题干我们可以了解到，当一个版本为正确版本后，之前所有的版本都是正确版本，当一个版本为错误版本后之后的版本都是错误版本，我们所做的就是需要找到第一个出错的版本，就可以利用二分查找来确定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution extends VersionControl &#123;</span><br><span class="line">    public int firstBadVersion(int n) &#123;</span><br><span class="line">        int left = 1, right = n;</span><br><span class="line">        while (left &lt; right) &#123; // 循环直至区间左右端点相同</span><br><span class="line">            int mid = left + (right - left) / 2; // 防止计算时溢出</span><br><span class="line">            if (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid; // 答案在区间 [left, mid] 中</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = mid + 1; // 答案在区间 [mid+1, right] 中</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 此时有 left == right，区间缩为一个点，即为答案</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5</p>
<p>输出: 2</p>
<p>示例 2:</p>
<p>输入: [1,3,5,6], 2</p>
<p>输出: 1</p>
<p>示例 3:</p>
<p>输入: [1,3,5,6], 7</p>
<p>输出: 4</p>
<p>示例 4:</p>
<p>输入: [1,3,5,6], 0</p>
<p>输出: 0</p>
<p>此题结合了前两道题，找到那个数的位置是什么，在左右指针移动时我们就要考虑他的角标移动。而且我们还需要一个值来记录循环时需要插入的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int left = 0, right = n - 1, ans = n;</span><br><span class="line">        while (left &lt;= right) &#123;// 循环直至区间左右端点换位</span><br><span class="line">            int mid = ((right - left) &gt;&gt; 1) + left;// 防止计算时溢出</span><br><span class="line">            if (target &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = mid;//记录此次循环中间位置</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*ans存在的重要性，如果target大于nums中最大值，ans为n输出</span><br><span class="line">**/</span><br></pre></td></tr></table></figure>

<p><strong>小知识：</strong>是右移运算，在计算机中是一种运算操作，但是他的运算结果正好能对应一个整数的二分之一值，这就正好能代替数学上的除2运算，但是比除2运算要快。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>分治</title>
    <url>/posts/2579510026.html/</url>
    <content><![CDATA[<p>其实对于分治算法，如果有了解快速排序，归并排序的同学，其实就懂得差不多了</p>
<p>分治，也就是分而治之。</p>
<p>它的一般步骤是 </p>
<p>① 将原问题分解成若干个规模较小的子问题（子问题和原问题的结构一样，只是规模不一样） </p>
<p>② 子问题又不断分解成规模更小的子问题，直到不能再分解（直到可以轻易计算出子问题的解）</p>
<p>③ 利用子问题的解推导出原问题的解 </p>
<p>因此，分治策略非常适合用递归 需要注意的是：子问题之间是相互独立的</p>
<p> <img src="/posts/2579510026.html/1629392416151-9be4de64-a111-4b28-a718-15b7098ce34c.png" alt="image.png"></p>
<h1 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h1><p><img src="/posts/2579510026.html/1629392455370-24166873-2f87-4821-b95e-fc67acced07d.png" alt="image.png"></p>
<p>因为公式太复杂了，就直接上图了</p>
<h1 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h1><p>我们还是通过做题来讲解一下分治的运用</p>
<p>问题：</p>
<p><strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]</p>
<p><strong>输出：</strong>6</p>
<p><strong>解释：</strong>连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
<p>这道题也属于最大切片问题（最大区段，Greatest Slice）</p>
<p>概念区分 </p>
<p>子串、子数组、子区间必须是连续的，子序列是可以不连续的</p>
<h2 id="暴力出奇迹"><a href="#暴力出奇迹" class="headerlink" title="暴力出奇迹"></a>暴力出奇迹</h2><p>这中解题方法我们丝毫都不推荐，暴力的确能解决问题，但是花费的时间太长了，损耗也很高；穷举出所有可能的连续子序列，并计算出它们的和，最后取它们中的最大值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int maxSubarray2(int[] nums) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) return 0;</span><br><span class="line">    int max = Integer.MIN_VALUE;</span><br><span class="line">    for (int begin = 0; begin &lt; nums.length; begin++) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int end = begin; end &lt; nums.length; end++) &#123;</span><br><span class="line">            // sum是[begin, end]的和</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度O(1)</p>
<p>时间复杂度O(n2)</p>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>将序列均匀地分割成 2 个子序列</p>
<p>[begin , end) = [begin , mid) + [mid , end)，mid = (begin + end) &gt;&gt; 1</p>
<p>假设 [begin , end) 的最大连续子序列和是 S[i , j) ，那么它有 3 种可能</p>
<p>[i , j) 存在于 [begin , mid) 中，同时 S[i , j) 也是 [begin , mid) 的最大连续子序列和</p>
<p>[i , j) 存在于 [mid , end) 中，同时 S[i , j) 也是 [mid , end) 的最大连续子序列和</p>
<p>[i , j) 一部分存在于 [begin , mid) 中，另一部分存在于 [mid , end) 中</p>
<p>[i , j) = [i , mid) + [mid , j)</p>
<p>S[i , mid) = max { S[k , mid) }，begin ≤ k ＜ mid</p>
<p>S[mid , j) = max { S[mid , k) }，mid ＜ k ≤ end</p>
<p><img src="/posts/2579510026.html/1629435140141-10721fe3-8da1-4879-92eb-721e0a2f5fb1.png" alt="image.png"></p>
<p>简笔画</p>
<p><img src="/posts/2579510026.html/1629437218166-baa65623-39b7-4e33-9bb6-8b5dbcb012a3.jpeg" alt="QQ图片20210820132406.jpg"></p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int[] nums = &#123;-2, 1, -3, 4, -1, 2, 1, -5, 4 &#125;;</span><br><span class="line">       System.out.println(maxSubArray(nums));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static int maxSubArray(int[] nums) &#123;</span><br><span class="line">       if (nums == null || nums.length == 0) &#123;return 0;&#125;</span><br><span class="line">       return maxSubArray(nums, 0, nums.length);</span><br><span class="line">   &#125;</span><br><span class="line">   static int maxSubArray(int[] nums, int begin, int end) &#123;</span><br><span class="line"></span><br><span class="line">       if (end - begin &lt; 2)</span><br><span class="line">       &#123;return nums[begin];&#125;</span><br><span class="line">       int mid = (begin + end) &gt;&gt; 1;</span><br><span class="line">       int leftMax = nums[mid - 1];</span><br><span class="line">       int leftSum = leftMax;</span><br><span class="line">       for (int i = mid - 2; i &gt;= begin; i--) &#123;</span><br><span class="line">           leftSum += nums[i];</span><br><span class="line">           leftMax = Math.max(leftMax, leftSum);</span><br><span class="line">       &#125;</span><br><span class="line">       int rightMax = nums[mid];</span><br><span class="line">       int rightSum = rightMax;</span><br><span class="line">       for (int i = mid + 1; i &lt; end; i++) &#123;</span><br><span class="line">           rightSum += nums[i];</span><br><span class="line">           rightMax = Math.max(rightMax, rightSum);</span><br><span class="line">       &#125;</span><br><span class="line">       return Math.max(leftMax + rightMax,</span><br><span class="line">               Math.max(</span><br><span class="line">                       maxSubArray(nums, begin, mid),</span><br><span class="line">                       maxSubArray(nums, mid, end))</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/2579510026.html/1629437585649-f099c164-3583-4e93-9b07-1d11b61c041a.png" alt="image.png"></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>分治并不是这道题的最优解，还有一种更好的解题方式</p>
<p>（此处应该有链接）</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>分治和动态规划的时间复杂度相同，但是因为分治使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？</p>
<p>对于这道题而言，确实是如此的。但是仔细观察分治，它不仅可以解决区间 [0, n-1][0,n−1]，还可以用于解决任意的子区间 [l,r][l,r] 的问题。如果我们把 [0, n-1][0,n−1] 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后，我们就可以在 O(\log n)O(logn) 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(\log n)O(logn) 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>分治</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/posts/2443699409.html/</url>
    <content><![CDATA[<h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title=" 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/"> 有序数组的平方</a></h1><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：</p>
<p>输入：nums = [-4,-1,0,3,10]</p>
<p>输出：[0,1,9,16,100]</p>
<p>解释：平方后，数组变为 [16,1,0,9,100]</p>
<p>排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2：</p>
<p>输入：nums = [-7,-3,2,3,11]</p>
<p>输出：[4,9,9,49,121]</p>
<p>方法一：直接排序</p>
<p>思路与算法</p>
<p><strong>方法一：直接排序（自己想到的）</strong></p>
<p><strong>思路与算法</strong></p>
<p>最简单的方法就是将数组 <em>nums</em> 中的数平方后直接排序。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        int[] ans = new int[nums.length];</span><br><span class="line">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            ans[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(nlogn)，其中 n 是数组 nums 的长度。</li>
</ul>
<ul>
<li>空间复杂度：O(logn)。除了存储答案的数组以外，我们需要 O(logn) 的栈空间进行排序。</li>
</ul>
<p><strong>方法二：双指针</strong></p>
<p><strong>思路与算法</strong></p>
<p>方法一没有利用「数组nums 已经按照升序排序」这个条件。显然，如果数组 nums 中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组 nums 中的所有数都是负数，那么将每个数平方后，数组会保持降序。</p>
<p>由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置 \textit{neg}neg 和 \textit{neg}+1neg+1，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int negative = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] &lt; 0) &#123;</span><br><span class="line">                negative = i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] ans = new int[n];</span><br><span class="line">        int index = 0, i = negative, j = negative + 1;</span><br><span class="line">        while (i &gt;= 0 || j &lt; n) &#123;</span><br><span class="line">            if (i &lt; 0) &#123;</span><br><span class="line">                ans[index] = nums[j] * nums[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; else if (j == n) &#123;</span><br><span class="line">                ans[index] = nums[i] * nums[i];</span><br><span class="line">                --i;</span><br><span class="line">            &#125; else if (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;</span><br><span class="line">                ans[index] = nums[i] * nums[i];</span><br><span class="line">                --i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans[index] = nums[j] * nums[j];</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{nums}nums 的长度。</p>
<p>空间复杂度：O(1)O(1)。除了存储答案的数组以外，我们只需要维护常量空间。</p>
<p><strong>方法三：双指针</strong></p>
<p><strong>思路与算法</strong></p>
<p>同样地，我们可以使用两个指针分别指向位置 00 和 n-1n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，读者可以仔细思考其精髓所在。</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] ans = new int[n];</span><br><span class="line">        for (int i = 0, j = n - 1, pos = n - 1; i &lt;= j;) &#123;</span><br><span class="line">            if (nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;</span><br><span class="line">                ans[pos] = nums[i] * nums[i];</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans[pos] = nums[j] * nums[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            --pos;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{nums}nums 的长度。</li>
<li>空间复杂度：O(1)O(1)。除了存储答案的数组以外，我们只需要维护常量空间。</li>
</ul>
<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p><strong>进阶：</strong></p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</p>
<p>你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,4,5,6,7], k = 3</p>
<p>输出: [5,6,7,1,2,3,4]</p>
<p>解释:</p>
<p>向右旋转 1 步: [7,1,2,3,4,5,6]</p>
<p>向右旋转 2 步: [6,7,1,2,3,4,5]</p>
<p>向右旋转 3 步: [5,6,7,1,2,3,4]</p>
<p>示例 2:</p>
<p>输入：nums = [-1,-100,3,99], k = 2</p>
<p>输出：[3,99,-1,-100]</p>
<p>解释: </p>
<p>向右旋转 1 步: [99,-1,-100,3]</p>
<p>向右旋转 2 步: [3,99,-1,-100]</p>
<p><strong>使用额外的数组</strong></p>
<p>我们可以使用额外的数组来将每个元素放至正确的位置。用 nn 表示数组的长度，我们遍历原数组，将原数组下标为 ii 的元素放至新数组下标为 （i+k)mod n 的位置，最后将新数组拷贝至原数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] newArr = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            newArr[(i + k) % n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(newArr, 0, nums, 0, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度： O(n)<em>O</em>(<em>n</em>)，其中 n<em>n</em> 为数组的长度。</li>
<li>空间复杂度： O(n)<em>O</em>(<em>n</em>)。</li>
</ul>
<p><strong>数组翻转</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>原始数组</td>
<td>1 2 3 4 5 6 7</td>
</tr>
<tr>
<td>翻转所有元素</td>
<td>7 6 5 4 3 2 1</td>
</tr>
<tr>
<td>翻转[0，k mod n-1]区间的元素</td>
<td>5 6 7 4 3 2 1</td>
</tr>
<tr>
<td>翻转[k mod n,n-1]区间的元素</td>
<td>5 6 7 1 2 3 4</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, 0, nums.length - 1);</span><br><span class="line">        reverse(nums, 0, k - 1);</span><br><span class="line">        reverse(nums, k, nums.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reverse(int[] nums, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            int temp = nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start += 1;</span><br><span class="line">            end -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)O(n)，其中 nn 为数组的长度。每个元素被翻转两次，一共 nn 个元素，因此总时间复杂度为 O(2n)=O(n)O(2n)=O(n)。</li>
<li>空间复杂度：O(1)O(1)。</li>
</ul>
<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]</p>
<p>输出: [1,3,12,0,0]</p>
<p>题解是用了双指针的方式来解决这个问题；使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int n = nums.length, left = 0, right = 0;</span><br><span class="line">        while (right &lt; n) &#123;</span><br><span class="line">            if (nums[right] != 0) &#123; </span><br><span class="line">                swap(nums, left, right);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swap(int[] nums, int left, int right) &#123;</span><br><span class="line">        int temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我当时的想法是，找到数组中不为零的数，按照顺序重新排列，最后没有数的位置补零即可，因为省去了交换的，会节省比较多的时间，也有点走题目漏洞的感觉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int indexNow = 0;</span><br><span class="line">        int indexNum = 0;</span><br><span class="line">        int m = nums.length;</span><br><span class="line"></span><br><span class="line">        while(indexNum&lt;m)&#123;</span><br><span class="line">            if(nums[indexNum] != 0) &#123;</span><br><span class="line">                nums[indexNow++] = nums[indexNum];</span><br><span class="line">            &#125;</span><br><span class="line">            ++indexNum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = indexNow; i &lt; m; i++)&#123;</span><br><span class="line">            nums[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两数之和——输入有数有序数组"><a href="#两数之和——输入有数有序数组" class="headerlink" title="两数之和——输入有数有序数组"></a>两数之和——输入有数有序数组</h1><p>给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<p>示例 1：</p>
<p>输入：numbers = [2,7,11,15], target = 9</p>
<p>输出：[1,2]</p>
<p>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p>
<p>示例 2：</p>
<p>输入：numbers = [2,3,4], target = 6</p>
<p>输出：[1,3]</p>
<p>示例 3：</p>
<p>输入：numbers = [-1,0], target = -1</p>
<p>输出：[1,2]</p>
<p>最开始的想法是想确定一个数，在找到另一个数，后来发现这种方法太费时间，但是后来官方还是给出了这种解法的题解（当时就觉得每个数都要找一遍很费时间，就没有细化的想下去。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        for (int i = 0; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            int low = i + 1, high = numbers.length - 1;</span><br><span class="line">            while (low &lt;= high) &#123;</span><br><span class="line">                int mid = (high - low) / 2 + low;</span><br><span class="line">                if (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                    return new int[]&#123;i + 1, mid + 1&#125;;</span><br><span class="line">                &#125; else if (numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                    high = mid - 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    low = mid + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我还是比较热衷有第二种双指针的解法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        int low = 0, high = numbers.length - 1;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            int sum = numbers[low] + numbers[high];</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                return new int[]&#123;low + 1, high + 1&#125;;</span><br><span class="line">            &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                ++low;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                --high;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>示例 1：</p>
<p>输入：[“h”,”e”,”l”,”l”,”o”]</p>
<p>输出：[“o”,”l”,”l”,”e”,”h”]</p>
<p>示例 2：</p>
<p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]</p>
<p>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<p>这题什么都不要说了，就记录一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reverseString(char[] s) &#123;</span><br><span class="line">        int n = s.length;</span><br><span class="line">        for (int left = 0, right = n - 1; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            char tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h1><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<p>示例：</p>
<p>输入：”Let’s take LeetCode contest”</p>
<p>输出：”s’teL ekat edoCteeL tsetnoc”</p>
<p>刚开始就想到了不好的东西导致解题思路一直不对，仔细读了题干发现，和上道题不一样，可以开辟新的空间。</p>
<p>开辟一个新字符串。然后从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词，并能得到单词的起止位置。随后，根据单词的起止位置，可以将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串，就能得到翻转后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        StringBuffer ret = new StringBuffer();</span><br><span class="line">        int length = s.length();</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i &lt; length) &#123;</span><br><span class="line">            int start = i;</span><br><span class="line">            while (i &lt; length &amp;&amp; s.charAt(i) != &#x27; &#x27;) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int p = start; p &lt; i; p++) &#123;</span><br><span class="line">                ret.append(s.charAt(start + i - 1 - p));</span><br><span class="line">            &#125;</span><br><span class="line">            while (i &lt; length &amp;&amp; s.charAt(i) == &#x27; &#x27;) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                ret.append(&#x27; &#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来查了百度，发现，可以利用toCharArray()方法将字符串转变成数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        char[] array = s.toCharArray();</span><br><span class="line">        int start = 0;</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            if (array[i] == &#x27; &#x27;) &#123;</span><br><span class="line">                reverse(array, start, i - 1);</span><br><span class="line">                start = i + 1; // 更新start为下一个单词的左索引</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == array.length - 1) &#123;</span><br><span class="line">                reverse(array, start, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void reverse(char[] array, int l, int r) &#123;</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            char temp = array[l];</span><br><span class="line">            array[l] = array[r];</span><br><span class="line">            array[r] = temp;</span><br><span class="line">            l += 1;</span><br><span class="line">            r -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>双指针</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/posts/4180606813.html/</url>
    <content><![CDATA[<p><strong>含义：</strong></p>
<p>回溯可以理解为通过选择不同的岔路口来通往目的地（找到想要的结果）； 每一步都选择一条路出发，能进则进，不能进则退回上一步（回溯），换一条路再试</p>
<p>树、图的深度优先搜索（DFS）、八皇后、走迷宫都是典型的回溯应用</p>
<p><img src="/posts/4180606813.html/1629215002802-ea35ae8b-f726-45ec-9941-04ace1b34437.png" alt="image.png"></p>
<p>不难看出来，回溯很适合使用递归 </p>
<h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><p>要知道想要明白一种算法，最直接的方式就是做一道题去理解它，再多的理论都要架在做题的基础之上</p>
<p>八皇后问题是一个古老而著名的问题 </p>
<p>在8x8格的国际象棋上摆放八个皇后，使其不能互相攻击：任意两个皇后都不能处于同一行、同一列、同一斜线上 </p>
<p>请问有多少种摆法？</p>
<p><img src="/posts/4180606813.html/1629215505310-a10d9f1a-2453-46ee-8d8b-05c2b283a93c.png" alt="image.png"></p>
<p>leetcode_51_N皇后：<a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens/</a></p>
<p>leetcode_52_N皇后 II： <a href="https://leetcode-cn.com/problems/n-queens-ii/">https://leetcode-cn.com/problems/n-queens-ii/</a> </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一、暴力破解，正所谓大力出奇迹，暴力的确可以解决问题，但是必不可面的就是他浪费了大量的资源，我们所得到的和所花费的不成比例，也不是我们学习算法的初衷；从 64 个格子中选出任意 8 个格子摆放皇后，检查每一种摆法的可行性，一共 C648种摆法（大概是 4.4 ∗ 109 种摆法）；根据题意，很显然，每一行只能放一个皇后，所以共有 88 种摆法（16777216 种），检查每一种摆法的可行性</p>
<p>二、回溯法</p>
<p>回溯+剪枝</p>
<h3 id="四皇后——回溯法"><a href="#四皇后——回溯法" class="headerlink" title="四皇后——回溯法"></a>四皇后——回溯法</h3><p>在解决八皇后问题之前，我们并不需要那么大的数据规模，我们可以先解决四皇后问题，在变换成八皇后，因为代码的思路是相同的</p>
<p>看图须知：我们四皇后问题在4×4的表格内，就说明在每行每列都应该存在且仅存在一个皇后。</p>
<p><img src="/posts/4180606813.html/1629215964841-c686131e-24b0-463a-b644-97e64854c7d9.png" alt="image.png"></p>
<p>如图所示，我们先选择（0，0）的位置作为第一个皇后，在剩下蓝色区域按序选择（1，2）位置作为第二个皇后的位置，但是我们发现第三行已经不能摆放皇后，说明我们之前摆放有问题，我们回到上一次摆放（图中3➡2），我们已经知道（1，2）不能摆放，我们按序拜访下一个位置（1，3）作为第二个皇后的位置，在剩下蓝色区域按序选择（2，1）位置作为第三个皇后的位置，此时我们发现第四行无摆放皇后位置，说明我们前几次摆放错误，我们向前回溯时发现，我们第二行和第三行的蓝色位置我们都进行了尝试，所以我们回溯到第一次摆放皇后（图中5➡1）；我们按序更改第一次摆放皇后的位置，~</p>
<p>按照规则我们进行摆放，当我们成功时，我们进行上一行的回溯，如果不行，继续上跳，当第一行将每个位置尝试过之后，我们就可以有多少种摆放方法。</p>
<h3 id="四皇后-–-剪枝"><a href="#四皇后-–-剪枝" class="headerlink" title="四皇后 – 剪枝"></a>四皇后 – 剪枝</h3><p><img src="/posts/4180606813.html/1629216763311-78fd3b4d-558a-46b1-9629-df66bcf85a84.png" alt="image.png"></p>
<p>剪枝，如图所示，就是将不符合条件的选项筛选掉。</p>
<h2 id="八皇后——回溯"><a href="#八皇后——回溯" class="headerlink" title="八皇后——回溯"></a>八皇后——回溯</h2><p><img src="/posts/4180606813.html/1629216844047-212df020-3b63-4891-8519-4de20994d86d.png" alt="image.png"></p>
<p><img src="/posts/4180606813.html/1629216867163-a953c44b-53d0-4f47-af55-e38bcf1e55fe.png" alt="image.png"></p>
<p><img src="/posts/4180606813.html/1629216874315-87ebd62d-738a-4208-a63f-0b2d5aaa0da1.png" alt="image.png"></p>
<p>先是通过四皇后来整理了思路，现在我们开始上代码</p>
<p><strong>*示例：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    new Queens().placeQueens(4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 数组索引是行号，数组元素是列号</span><br><span class="line"> */</span><br><span class="line">int[] cols;</span><br><span class="line">/**</span><br><span class="line"> * 一共有多少种摆法</span><br><span class="line"> */</span><br><span class="line">int ways;</span><br><span class="line"></span><br><span class="line">void placeQueens(int n) &#123;</span><br><span class="line">    if (n &lt; 1) return;</span><br><span class="line">    cols = new int[n];</span><br><span class="line">    place(0);</span><br><span class="line">    System.out.println(n + &quot;皇后一共有&quot; + ways + &quot;种摆法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从第row行开始摆放皇后</span><br><span class="line"> * @param row</span><br><span class="line"> */</span><br><span class="line">void place(int row) &#123;</span><br><span class="line">    if (row == cols.length) &#123;</span><br><span class="line">        ways++;</span><br><span class="line">        show();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int col = 0; col &lt; cols.length; col++) &#123;</span><br><span class="line">        if (isValid(row, col)) &#123;</span><br><span class="line">            // 在第row行第col列摆放皇后</span><br><span class="line">            cols[row] = col;</span><br><span class="line">            place(row + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断第row行第col列是否可以摆放皇后</span><br><span class="line"> */</span><br><span class="line">boolean isValid(int row, int col) &#123;</span><br><span class="line">    for (int i = 0; i &lt; row; i++) &#123;</span><br><span class="line">        // 第col列已经有皇后</span><br><span class="line">        if (cols[i] == col) &#123;</span><br><span class="line">            System.out.println(&quot;[&quot; + row + &quot;][&quot; + col + &quot;]=false&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第i行的皇后跟第row行第col列格子处在同一斜线上</span><br><span class="line">        if (row - i == Math.abs(col - cols[i])) &#123;</span><br><span class="line">            System.out.println(&quot;[&quot; + row + &quot;][&quot; + col + &quot;]=false&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;[&quot; + row + &quot;][&quot; + col + &quot;]=true&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show() &#123;</span><br><span class="line">    for (int row = 0; row &lt; cols.length; row++) &#123;</span><br><span class="line">        for (int col = 0; col &lt; cols.length; col++) &#123;</span><br><span class="line">            if (cols[row] == col) &#123;</span><br><span class="line">                System.out.print(&quot;1 &quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.print(&quot;0 &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八皇后——优化1"><a href="#八皇后——优化1" class="headerlink" title="八皇后——优化1"></a>八皇后——优化1</h3><p>我们可以很好的找到皇后所对应的行列，但是对于他的对角线问题我们就不能快速的解决</p>
<p><img src="/posts/4180606813.html/1629218440471-1aec547f-f62a-465c-b5e0-7010089503d2.png" alt="image.png"></p>
<p>看到这幅图的时候我相信大家都明白了，我们按照这种对角线的方式我们能很好的找到我们斜线</p>
<p>我们将整型数组变成了布尔类型</p>
<p><strong>*示例：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        new Queens2().placeQueens(4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 数组索引是行号，数组元素是列号</span><br><span class="line">     */</span><br><span class="line">    int[] queens;</span><br><span class="line">    /**</span><br><span class="line">     * 标记着某一列是否有皇后</span><br><span class="line">     */</span><br><span class="line">    boolean[] cols;</span><br><span class="line">    /**</span><br><span class="line">     * 标记着某一斜线上是否有皇后（左上角 -&gt; 右下角）</span><br><span class="line">     */</span><br><span class="line">    boolean[] leftTop;</span><br><span class="line">    /**</span><br><span class="line">     * 标记着某一斜线上是否有皇后（右上角 -&gt; 左下角）</span><br><span class="line">     */</span><br><span class="line">    boolean[] rightTop;</span><br><span class="line">    /**</span><br><span class="line">     * 一共有多少种摆法</span><br><span class="line">     */</span><br><span class="line">    int ways;</span><br><span class="line">    </span><br><span class="line">    void placeQueens(int n) &#123;</span><br><span class="line">        if (n &lt; 1) return;</span><br><span class="line">        queens = new int[n];</span><br><span class="line">        cols = new boolean[n];</span><br><span class="line">        leftTop = new boolean[(n &lt;&lt; 1) - 1];</span><br><span class="line">        rightTop = new boolean[leftTop.length];</span><br><span class="line">        place(0);</span><br><span class="line">        System.out.println(n + &quot;皇后一共有&quot; + ways + &quot;种摆法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 从第row行开始摆放皇后</span><br><span class="line">     * @param row</span><br><span class="line">     */</span><br><span class="line">    void place(int row) &#123;</span><br><span class="line">        if (row == cols.length) &#123;</span><br><span class="line">            ways++;</span><br><span class="line">            show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int col = 0; col &lt; cols.length; col++) &#123;</span><br><span class="line">            if (cols[col]) continue;</span><br><span class="line">            int ltIndex = row - col + cols.length - 1;</span><br><span class="line">            if (leftTop[ltIndex]) continue;</span><br><span class="line">            int rtIndex = row +col;</span><br><span class="line">            if (rightTop[rtIndex]) continue;</span><br><span class="line">            </span><br><span class="line">            queens[row] = col;</span><br><span class="line">            cols[col] = true;</span><br><span class="line">            leftTop[ltIndex] = true;</span><br><span class="line">            rightTop[rtIndex] = true;</span><br><span class="line">            place(row + 1);</span><br><span class="line">            //我们必须要将它回到原位</span><br><span class="line">            cols[col] = false;</span><br><span class="line">            leftTop[ltIndex] = false;</span><br><span class="line">            rightTop[rtIndex] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void show() &#123;</span><br><span class="line">        for (int row = 0; row &lt; cols.length; row++) &#123;</span><br><span class="line">            for (int col = 0; col &lt; cols.length; col++) &#123;</span><br><span class="line">                if (queens[row] == col) &#123;</span><br><span class="line">                    System.out.print(&quot;1 &quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.print(&quot;0 &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="八皇后——优化2"><a href="#八皇后——优化2" class="headerlink" title="八皇后——优化2"></a>八皇后——优化2</h3><p>这种优化只限于八皇后，或者更少的皇后，但是一种思路，我看到别人家的都有，我也要有。</p>
<p><strong>*示例：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // 01111101 n</span><br><span class="line">        //&amp;11111011  ~00000100</span><br><span class="line">        // 01111001</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //&amp;00100000 v</span><br><span class="line">//      int n = 125;</span><br><span class="line">//      for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">//          int result = n &amp; (1 &lt;&lt; i);</span><br><span class="line">//          System.out.println(i + &quot;_&quot; + (result != 0));</span><br><span class="line">//      &#125;</span><br><span class="line">//      int col = 7;</span><br><span class="line">//      int result = n &amp; (1 &lt;&lt; col);</span><br><span class="line">//      System.out.println(result != 0);</span><br><span class="line">        </span><br><span class="line">//      System.out.println(Integer.toBinaryString(n));</span><br><span class="line">        </span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        new Queens3().place8Queens();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 数组索引是行号，数组元素是列号</span><br><span class="line">     */</span><br><span class="line">    int[] queens;</span><br><span class="line">    /**</span><br><span class="line">     * 标记着某一列是否有皇后</span><br><span class="line">     */</span><br><span class="line">    byte cols;</span><br><span class="line">    /**</span><br><span class="line">     * 标记着某一斜线上是否有皇后（左上角 -&gt; 右下角）</span><br><span class="line">     */</span><br><span class="line">    short leftTop;</span><br><span class="line">    /**</span><br><span class="line">     * 标记着某一斜线上是否有皇后（右上角 -&gt; 左下角）</span><br><span class="line">     */</span><br><span class="line">    short rightTop;</span><br><span class="line">    /**</span><br><span class="line">     * 一共有多少种摆法</span><br><span class="line">     */</span><br><span class="line">    int ways;</span><br><span class="line">    </span><br><span class="line">    void place8Queens() &#123;</span><br><span class="line">        queens = new int[8];</span><br><span class="line">        place(0);</span><br><span class="line">        System.out.println(&quot;8皇后一共有&quot; + ways + &quot;种摆法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 从第row行开始摆放皇后</span><br><span class="line">     * @param row</span><br><span class="line">     */</span><br><span class="line">    void place(int row) &#123;</span><br><span class="line">        if (row == 8) &#123;</span><br><span class="line">            ways++;</span><br><span class="line">            show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int col = 0; col &lt; 8; col++) &#123;</span><br><span class="line">            int cv = 1 &lt;&lt; col;</span><br><span class="line">            if ((cols &amp; cv) != 0) continue;</span><br><span class="line">            </span><br><span class="line">            int lv = 1 &lt;&lt; (row - col + 7);</span><br><span class="line">            if ((leftTop &amp; lv) != 0) continue;</span><br><span class="line">            </span><br><span class="line">            int rv = 1 &lt;&lt; (row + col);</span><br><span class="line">            if ((rightTop &amp; rv) != 0) continue;</span><br><span class="line">            </span><br><span class="line">            queens[row] = col;</span><br><span class="line">            cols |= cv;</span><br><span class="line">            leftTop |= lv;</span><br><span class="line">            rightTop |= rv;</span><br><span class="line">            place(row + 1);</span><br><span class="line">            cols &amp;= ~cv;</span><br><span class="line">            leftTop &amp;= ~lv;</span><br><span class="line">            rightTop &amp;= ~rv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void show() &#123;</span><br><span class="line">        for (int row = 0; row &lt; 8; row++) &#123;</span><br><span class="line">            for (int col = 0; col &lt; 8; col++) &#123;</span><br><span class="line">                if (queens[row] == col) &#123;</span><br><span class="line">                    System.out.print(&quot;1 &quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.print(&quot;0 &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>









<p>本文代码均可进行复制粘贴到编译器，后进行debug，来了解代码运行过程</p>
<p>有问题可进行留言，博主看后回复</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/posts/3993241091.html/</url>
    <content><![CDATA[<p><strong>前言：</strong></p>
<p>唉！昨天学了一天的并查集，但是觉得自己并没有搞的特别明白，就算写笔记意义也不大，先跳过了，过一段时间之后再来学习并查集，但是这个图还算是可以。</p>
<p><strong>介绍：</strong></p>
<p>图由顶点（vertex）和边（edge）组成，通常表示为 G = (V, E)；</p>
<p>G表示一个图，V是顶点集，E是边集；</p>
<p>顶点集V有穷且非空；</p>
<p>任意两个顶点之间都可以用边来表示它们之间的关系，边集E可以是空的</p>
<p><img src="/posts/3993241091.html/1628657582650-5905f0d7-8048-4ed2-aff3-1254333da474.png" alt="image.png"></p>
<p><strong>应用场景：</strong></p>
<p><img src="/posts/3993241091.html/1628658038315-f4ac6809-634b-4739-b19e-eaf32a6e12ed.png" alt="image.png"><img src="/posts/3993241091.html/1628658049366-fac998a5-eb2e-4a9d-91a6-312b0981b1a4.png" alt="image.png"></p>
<p>社交网络，地图等。。。</p>
<h1 id="图的种类"><a href="#图的种类" class="headerlink" title="图的种类"></a>图的种类</h1><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p> 有向图的边是有明确方向的 </p>
<p><img src="/posts/3993241091.html/1628658114609-b922cfd6-6cb6-4cee-8723-5701cc7c83a6.png" alt="image.png"></p>
<p><strong>有向无环图</strong>（Directed Acyclic Graph，简称 DAG） 如果一个有向图，从任意顶点出发无法经过若干条边回到该顶点，那么它就是一个有向无环图 </p>
<p><img src="/posts/3993241091.html/1628658150350-dbb579eb-c0aa-4d47-b378-d581a75f3ae8.png" alt="image.png"></p>
<h4 id="出度、入度"><a href="#出度、入度" class="headerlink" title="出度、入度"></a>出度、入度</h4><p>出度、入度适用于有向图</p>
<p>出度（Out-degree） 一个顶点的出度为 x，是指有 x 条边以该顶点为起点 顶点11的出度是3</p>
<p>入度（In-degree） 一个顶点的入度为 x，是指有 x 条边以该顶点为终点 顶点11的入度是2 </p>
<p><img src="/posts/3993241091.html/1628658209857-56ee3748-30c9-4f9f-b5d4-37df32a42bb4.png" alt="image.png"></p>
<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><p>无向图的边是无方向的 </p>
<p><img src="/posts/3993241091.html/1628658285899-9dfa0f08-a9bf-4a4f-8cc8-8e6c601a889a.png" alt="image.png"></p>
<p>效果类似于下面的有向图 </p>
<p><img src="/posts/3993241091.html/1628658298899-100cd689-ede8-4581-a37d-81f26a1f3549.png" alt="image.png"></p>
<h3 id="混合图"><a href="#混合图" class="headerlink" title="混合图"></a>混合图</h3><p><img src="/posts/3993241091.html/1628658323152-39ef204a-6fc2-4d31-83b4-9631dd8e9ed3.png" alt="image.png"></p>
<h3 id="简单图、多重图"><a href="#简单图、多重图" class="headerlink" title="简单图、多重图"></a>简单图、多重图</h3><p><strong>平行边</strong> </p>
<p>在无向图中，关联一对顶点的无向边如果多于1条，则称这些边为平行边 在有向图中，关联一对顶点的有向边如果多于1条，并且它们的的方向相同，则称这些边为平行边</p>
<p><strong>多重图</strong>（Multigraph） 有平行边或者有自环的图； <strong>简单图</strong>（Simple Graph） 既没有平行边也不没有自环的图 </p>
<p><img src="/posts/3993241091.html/1628658483116-61cd81dc-5b18-45d3-8f8e-7cfa3a8d3dcf.png" alt="image.png"></p>
<h3 id="无向完全图"><a href="#无向完全图" class="headerlink" title="无向完全图"></a>无向完全图</h3><p>无向完全图的任意两个顶点之间都存在边</p>
<p>n 个顶点的无向完全图有 n(n − 1)/2 条边 n − 1    +    n − 2    +    n − 3    + ⋯ + 3 + 2 + 1</p>
<p><img src="/posts/3993241091.html/1628658542366-b373073f-fb7c-4833-b4a5-7ceeec3d7f7c.png" alt="image.png"></p>
<h3 id="有向完全图"><a href="#有向完全图" class="headerlink" title="有向完全图"></a>有向完全图</h3><p>有向完全图的任意两个顶点之间都存在方向相反的两条边</p>
<p>n 个顶点的有向完全图有 n(n − 1) 条边 </p>
<p><img src="/posts/3993241091.html/1628659923141-9975a6d1-9d0a-4ed7-af83-886de691f9ee.png" alt="image.png"></p>
<p>稠密图（Dense Graph）：边数接近于或等于完全图 </p>
<p>稀疏图（Sparse Graph）：边数远远少于完全图 </p>
<h3 id="有权图"><a href="#有权图" class="headerlink" title="有权图"></a>有权图</h3><p><img src="/posts/3993241091.html/1628660181749-99a3d2f6-3959-4905-b4f6-e85d881da004.png" alt="image.png"></p>
<h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><p>如果顶点 x 和 y 之间存在可相互抵达的路径（直接或间接的路径），则称 x 和 y 是连通的</p>
<p>如果无向图 G 中任意2个顶点都是连通的，则称G为连通图 </p>
<p><img src="/posts/3993241091.html/1628660235400-1cd3ba4c-4ac5-4651-97d8-a124a44462ac.png" alt="image.png"></p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p>连通分量：无向图的极大连通子图</p>
<p>连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量</p>
<p>下面的无向图有3个连通分量 </p>
<p><img src="/posts/3993241091.html/1628660304778-9b8a3f15-1eb7-456a-88a4-2bca577a67f3.png" alt="image.png"></p>
<h3 id="强连通图"><a href="#强连通图" class="headerlink" title="强连通图"></a>强连通图</h3><p>如果有向图 G 中任意2个顶点都是连通的，则称G为强连通图 ,并不是说要直接相连,是相连就可以</p>
<p><img src="/posts/3993241091.html/1628660403565-45105917-c72e-475b-8010-fa6d1e881ca2.png" alt="image.png"></p>
<h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><p>有向图的极大强连通子图 强连通图只有一个强连通分量，即其自身；非强连通的有向图有多个强连通分量</p>
<p><img src="/posts/3993241091.html/1628660483437-931d45c4-73d9-485e-b647-b16632d76144.png" alt="image.png"></p>
<h1 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵的存储方式 </p>
<p>一维数组存放顶点信息 </p>
<p>二维数组存放边信息 </p>
<p><img src="/posts/3993241091.html/1628660634155-3d2274f0-fe5a-4e2e-bdb1-50776e66ad28.png" alt="image.png"></p>
<p> 邻接矩阵比较适合稠密图 不然会比较浪费内存</p>
<p><img src="/posts/3993241091.html/1628660873033-d0473340-487b-4048-aa7b-452669365b1d.png" alt="image.png"></p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><img src="/posts/3993241091.html/1628660898916-e281634c-9ddb-4b37-bc45-f271af608a4f.png" alt="image.png"></p>
<p><img src="/posts/3993241091.html/1628660923947-332eb67e-c1d4-48aa-9ea3-8b1a9ca32fef.png" alt="image.png"></p>
<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>图的遍历 </p>
<p>从图中某一顶点出发访问图中其余顶点，且每一个顶点仅被访问一次</p>
<p>图有2种常见的遍历方式（有向图、无向图都适用） </p>
<p>广度优先搜索（Breadth First Search，BFS），又称为宽度优先搜索、横向优先搜索  </p>
<p>深度优先搜索（Depth First Search，DFS） 发明“深度优先搜索”算法的2位科学家在1986年共同获得计算机领域的最高奖：图灵奖 </p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>二叉树层序遍历就是一种广度优先搜索 </p>
<p><img src="/posts/3993241091.html/1628683474690-544ac26b-2789-412f-a1ba-b72ecca36442.png" alt="image.png"></p>
<p><img src="/posts/3993241091.html/1628683484031-8270f91e-da27-4234-a836-8e47a0446578.png" alt="image.png"></p>
<p><img src="/posts/3993241091.html/1628683497620-bd67476c-3f7e-4c4e-b8a1-d3ed3002dea1.png" alt="image.png"></p>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>二叉树前序遍历就是一种深度优先搜索 </p>
<p><img src="/posts/3993241091.html/1628683533612-0234828a-8eee-4ff3-a8ff-41ed4de9da58.png" alt="image.png"></p>
<p><img src="/posts/3993241091.html/1628683544956-26b95925-b68a-4c1f-93f7-6cc54cee4111.png" alt="image.png"></p>
<p>图的知识还有许多,因为都是理论,学的不是很透彻,等着下会做题的时候一起写</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序2</title>
    <url>/posts/362397694.html/</url>
    <content><![CDATA[<p><strong>前言：</strong></p>
<p>因为排序的种类实在是太多了，放在一篇文章里显得过于冗杂，所以把简单的排序方法放在一起了。</p>
<p>今天要说的是归并排序，之前我没有接触，或者用过这个排序方式，也可能是我孤陋寡闻了。</p>
<p>归并排序是1945年由约翰·冯·诺伊曼（John von Neumann）首次提出 。</p>
<p><strong>原理：</strong></p>
<p>执行流程 ① 不断地将当前序列平均分割成2个子序列 直到不能再分割（序列中只剩1个元素）； ② 不断地将2个子序列合并成一个有序序列 直到最终只剩下1个有序序列</p>
<p><img src="/posts/362397694.html/1628328128618-6a6d0a8e-6650-4f27-b337-82d881a64fdc.png" alt="image.png"></p>
<p>归并排序的主要步骤分为两个部分，一个是分开，一个是合并</p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void sort() &#123;</span><br><span class="line">        leftArray = (T[]) new Comparable[array.length &gt;&gt; 1];</span><br><span class="line">        sort(0, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // T(n) = T(n/2) + T(n/2) + O(n)</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 对 [begin, end) 范围的数据进行归并排序</span><br><span class="line">     */</span><br><span class="line">    private void sort(int begin, int end) &#123;</span><br><span class="line">        if (end - begin &lt; 2) return;</span><br><span class="line">        </span><br><span class="line">        int mid = (begin + end) &gt;&gt; 1;</span><br><span class="line">        sort(begin, mid);</span><br><span class="line">        sort(mid, end);</span><br><span class="line">        merge(begin, mid, end);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当我们已经将数组切开之后，我们该考虑如何让数组有序的合并在一起。</p>
<p><img src="/posts/362397694.html/1628331170530-c49b9436-c1d6-4bc5-9e4b-4f7be396abf6.png" alt="image.png"></p>
<p>我们将子数组开头第一个数字称之为索引，我们两两比较索引大小，将较小的索引提出，放到新的数组中，去除索引的组数下一位就是新的索引。</p>
<p>但是，我们可能重新开辟一块新的空间来放置整理好后的数据； 需要 merge 的 2 组序列存在于同一个数组中，并且是挨在一起的，</p>
<p><img src="/posts/362397694.html/1628331732980-bb618b2e-adc4-4817-9c41-216b13a363bc.png" alt="image.png"></p>
<p>为了更好地完成 merge 操作，最好将其中 1 组序列备份出来，比如 [begin, mid) </p>
<p><img src="/posts/362397694.html/1628331755711-bf19d171-a3b9-4dc8-abe8-b31497890787.png" alt="image.png"></p>
<p>li == 0；le == mid – begin； ri == mid；re == end </p>
<p><img src="/posts/362397694.html/1628331871912-761186ff-65a2-44ac-b5ad-0544112a3326.png" alt="image.png"></p>
<p>我们排序到最后，两边数组总一个会先结束</p>
<p>当左边先结束的</p>
<p><img src="/posts/362397694.html/1628332296373-57dad76b-0ffb-4abd-b87f-49a1735914ef.png" alt="image.png"></p>
<p>左边先结束，就是右边有剩余，我们不需要任何操作</p>
<p>当右边先结束</p>
<p><img src="/posts/362397694.html/1628332470268-f456fc31-bc17-47d9-9de9-f465566a20a1.png" alt="image.png"></p>
<p>右边先结束，就是左边有剩余，我们需要将左边剩余部分原封不动的转移过来。</p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void merge(int begin, int mid, int end) &#123;</span><br><span class="line">        int li = 0, le = mid - begin;</span><br><span class="line">        int ri = mid, re = end;</span><br><span class="line">        int ai = begin;</span><br><span class="line"></span><br><span class="line">        // 备份左边数组</span><br><span class="line">        for (int i = li; i &lt; le; i++) &#123;</span><br><span class="line">            leftArray[i] = array[begin + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果左边还没有结束</span><br><span class="line">        while (li &lt; le) &#123;</span><br><span class="line">            if (ri &lt; re &amp;&amp; (array[ri]-leftArray[li]) &lt; 0) &#123;</span><br><span class="line">                array[ai++] = array[ri++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                array[ai++] = leftArray[li++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p><img src="/posts/362397694.html/image-20210807190819849.png" alt="image-20210807190819849"></p>
<p>这是一段完整的归并排序代码，可以debug来查看代码运行过程，深入学习</p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line">    private int[] leftArray;</span><br><span class="line">    private int[] array=&#123;1,4,2,12,16,19,7,8,3,9&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test t=new test();</span><br><span class="line">        t.sort();</span><br><span class="line">        for(int i=0;i&lt;t.array.length;i++)&#123;</span><br><span class="line">            System.out.println(t.array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected void sort() &#123;</span><br><span class="line">        leftArray = new int[array.length &gt;&gt; 1];</span><br><span class="line">        sort(0, array.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // T(n) = T(n/2) + T(n/2) + O(n)</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对 [begin, end) 范围的数据进行归并排序</span><br><span class="line">     */</span><br><span class="line">    private void sort(int begin, int end) &#123;</span><br><span class="line">        if (end - begin &lt; 2) &#123;return;&#125;</span><br><span class="line"></span><br><span class="line">        int mid = (begin + end) &gt;&gt; 1;</span><br><span class="line">        sort(begin, mid);</span><br><span class="line">        sort(mid, end);</span><br><span class="line">        merge(begin, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将 [begin, mid) 和 [mid, end) 范围的序列合并成一个有序序列</span><br><span class="line">     */</span><br><span class="line">    private void merge(int begin, int mid, int end) &#123;</span><br><span class="line">        int li = 0, le = mid - begin;</span><br><span class="line">        int ri = mid, re = end;</span><br><span class="line">        int ai = begin;</span><br><span class="line"></span><br><span class="line">        // 备份左边数组</span><br><span class="line">        for (int i = li; i &lt; le; i++) &#123;</span><br><span class="line">            leftArray[i] = array[begin + i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果左边还没有结束</span><br><span class="line">        while (li &lt; le) &#123;</span><br><span class="line">            if (ri &lt; re &amp;&amp; (array[ri]-leftArray[li]) &lt; 0) &#123;</span><br><span class="line">                array[ai++] = array[ri++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                array[ai++] = leftArray[li++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序1</title>
    <url>/posts/2755965992.html/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序可能是我们大部分人接触的第一个排序方法，也是最最最基础的算法了。</p>
<p><strong>原理</strong>：</p>
<p>​    比较两个相邻的元素，将值大的元素交换到右边</p>
<p><strong>思路：</strong></p>
<p>​    依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</p>
<p>　　　　(1)第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。</p>
<p>　　　　(2)比较第2和第3个数，将小数 放在前面，大数放在后面。</p>
<p>　　　　……</p>
<p>　　　　(3)如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成</p>
<p>　　　　(4)在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。</p>
<p>　　　　(5)在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。</p>
<p>　　　　(6)依次类推，每一趟比较次数减少依次</p>
<p><img src="/posts/2755965992.html/1.png" alt="image.png"></p>
<p>(2)第一趟排序：</p>
<p>　　　　　　第一次排序：10和1比较，10大于1，交换位置 　  [1,10,35,61,89,36,55]</p>
<p>　　　　　　第二趟排序：10和35比较，10小于35，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第三趟排序：35和61比较，35小于61，不交换位置　　[1,10,35,61,89,36,55]</p>
<p>　　　　　　第四趟排序：61和89比较，61小于89，不交换位置　　[1,10,35,61,89,36,55]</p>
<p> 　　　　 第五趟排序：89和36比较，89大于36，交换位置　　　[1,10,35,61,36,89,55]</p>
<p>　　　　　　第六趟排序：89和55比较，89大于55，交换位置　　　[1,10,35,61,36,55,89]</p>
<p>　　　　　　第一趟总共进行了六次比较，排序结果：[1,10,35,61,36,55,89]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[begin] &lt; array[begin - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[begin];</span><br><span class="line">                    array[begin] = array[begin - <span class="number">1</span>];</span><br><span class="line">                    array[begin - <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p>　　　　(1)由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p>
<p>　　　　(2)冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p>
<p><strong>优化1：（只能在数组前部部分有序的情况下优化）</strong></p>
<p>如果经过一次排序后，剩下未排序的数字已经排列好，无需剩下的多次循环排序；则我们应设定变量来控制终止剩下的循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[begin] &lt; array[begin - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[begin];</span><br><span class="line">                    array[begin] = array[begin - <span class="number">1</span>];</span><br><span class="line">                    array[begin - <span class="number">1</span>] = tmp;</span><br><span class="line">                    sorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sorted) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化2：（数组中有有序部分优化）</strong></p>
<p>在数组中，有着片段的子数组是有序的，在排序中我们不需要对他进行排列，可以将他视为一个整体进行排列；如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数 。</p>
<p><img src="/posts/2755965992.html/2.png" alt="出来吧.png"></p>
<p>最后1次交换的位置是6</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">            <span class="comment">// sortedIndex的初始值在数组完全有序的时候有用</span></span><br><span class="line">            <span class="keyword">int</span> sortedIndex = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[begin] &lt; array[begin - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[begin];</span><br><span class="line">                    array[begin] = array[begin - <span class="number">1</span>];</span><br><span class="line">                    array[begin - <span class="number">1</span>] = tmp;</span><br><span class="line">                    sortedIndex = begin;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end = sortedIndex;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p>最坏、平均时间复杂度：O(n2)； 最好时间复杂度：O(n) ；空间复杂度：O(1) ；</p>
<p>优化之后冒泡排序，能快速地将数组内，已经排好序的子数组，不经子数组内部排序，将子数组当成一个整体进行排序；在某个数组中有多个已排好序的子数组，在时间运算上有极大的提升。</p>
<p>如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法 </p>
<p>排序前：      5, 1,3𝑎, 4,7,3𝑏 </p>
<p>稳定的排序：   1,3𝑎, 3𝑏, 4,5,7 </p>
<p>不稳定的排序： 1, 3𝑏, 3𝑎,4, 5,7  </p>
<p>对自定义对象进行排序时，稳定性会影响最终的排序效果  </p>
<p>冒泡排序属于稳定的排序算法 稍有不慎，稳定的排序算法也能被写成不稳定的排序算法，比如下面的冒泡排序代码是不稳定的</p>
<p><img src="/posts/2755965992.html/1628229869158-d3d935de-990a-48f3-b99b-db4dfa487334.png" alt="image.png"></p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>在我看来选择排序的冒泡排序有着异曲同工之妙，两者的区别是冒泡排序是遇到比自己大的就进行一次交换，而选择排序是找到此次排序中的最大值之后再进行一次交换，减少了不必要的交换次数。</p>
<p><strong>原理：</strong></p>
<p>1.从序列中找出最大的那个元素，然后与最末尾的元素交换位置 执行完一轮后，最末尾的那个元素就是最大的元素；</p>
<p>2.忽略 1 中曾经找到的最大元素，重复执行步骤 1；</p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> end = array.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[maxIndex] &lt;= array[begin]) &#123;</span><br><span class="line">                    maxIndex = begin;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = array[maxIndex];</span><br><span class="line">            array[maxIndex] = array[end];</span><br><span class="line">            array[end] = tmp;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p>选择排序的交换次数要远远少于冒泡排序，平均性能优于冒泡排序 ；</p>
<p>最好、最坏、平均时间复杂度：O(n2)，空间复杂度：O(1)，属于不稳定排序 ；</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序的排序方式可以看成选择排序的优化，在未排序部分利用堆的方式来寻找最大值。</p>
<p><strong>原理：</strong></p>
<p>执行流程 ：① 对序列进行原地建堆（heapify）； ② 重复执行以下操作，直到堆的元素数量为 1 ；交换堆顶元素与尾元素 ；堆的元素数量减 1 ；对 0 位置进行 1 次 siftDown 操作</p>
<p><img src="/posts/2755965992.html/1628241066154-b2712219-05e7-4e1c-8fb4-00741b50283b.png" alt="image.png"><img src="/posts/2755965992.html/1628241075798-4cd4539b-67d1-486a-b405-a8f64e01cc26.png" alt="image.png"></p>
<p><img src="/posts/2755965992.html/1628241095710-259f3776-2b55-4059-b0db-b4e7d0f47a36.png" alt="image.png"></p>
<p><img src="/posts/2755965992.html/1628241106503-dd59400a-b050-443f-92c8-f82d4981d020.png" alt="image.png"></p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="comment">// 原地建堆</span></span><br><span class="line">        heapSize = array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (heapSize &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            siftDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (heapSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 交换堆顶元素和尾部元素</span></span><br><span class="line">            swap(<span class="number">0</span>, --heapSize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对0位置进行siftDown（恢复堆的性质）</span></span><br><span class="line">            siftDown(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        T element = array[index];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> half = heapSize &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; half) &#123; <span class="comment">// index必须是非叶子节点</span></span><br><span class="line">            <span class="comment">// 默认是左边跟父节点比</span></span><br><span class="line">            <span class="keyword">int</span> childIndex = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            T child = array[childIndex];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> rightIndex = childIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 右子节点比左子节点大</span></span><br><span class="line">            <span class="keyword">if</span> (rightIndex &lt; heapSize &amp;&amp; </span><br><span class="line">                    cmp(array[rightIndex], child) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                child = array[childIndex = rightIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 大于等于子节点</span></span><br><span class="line">            <span class="keyword">if</span> (cmp(element, child) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            array[index] = child;</span><br><span class="line">            index = childIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p>相较于选择排序，在选取最大值时利用了堆的数据结构，降低了复杂度，因为是利用数组原地进行建堆，所以空间复杂度为O(1)</p>
<p>最好、最坏、平均时间复杂度：O(nlogn)，空间复杂度：O(1)，属于不稳定排序 ；</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p> 插入排序非常类似于扑克牌的排序 </p>
<p><img src="/posts/2755965992.html/1628258813633-ed4291cd-e08a-4ef5-95c9-65ccd6be0153.png" alt="image.png"></p>
<p> <strong>原理****：</strong></p>
<p>① 在执行过程中，插入排序会将序列分为2部分 头部是已经排好序的，尾部是待排序的 </p>
<p>② 从头开始扫描每一个元素 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序 </p>
<p><img src="/posts/2755965992.html/1628258885938-05355391-0a96-4095-9511-b504ac6c2a50.png" alt="image.png"></p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = begin;</span><br><span class="line">        <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; cmp(cur, cur - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(cur, cur - <span class="number">1</span>);</span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *cmp</span></span><br><span class="line"><span class="comment"> * 返回值等于0，代表 array[i1] == array[i2]</span></span><br><span class="line"><span class="comment"> * 返回值小于0，代表 array[i1] &lt; array[i2]</span></span><br><span class="line"><span class="comment"> * 返回值大于0，代表 array[i1] &gt; array[i2]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *swap</span></span><br><span class="line"><span class="comment"> *交换</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h2 id="插入排序——逆序对"><a href="#插入排序——逆序对" class="headerlink" title="插入排序——逆序对"></a>插入排序——逆序对</h2><ul>
<li>什么是逆序对？</li>
</ul>
<p>数组 &lt;2,3,8,6,1&gt; 的逆序对为：&lt;2,1&gt; &lt;3,1&gt; &lt;8,1&gt; &lt;8,6&gt; &lt;6,1&gt;，共5个逆序对。</p>
<p><img src="/posts/2755965992.html/1628260358800-98a989db-7b64-4c94-b920-ede85d098ce1.png" alt="image.png"></p>
<p><strong>算法分析：</strong></p>
<p>最坏、平均时间复杂度：O(n2) </p>
<p>最好时间复杂度：O(n) </p>
<p>空间复杂度：O(1) </p>
<p>属于稳定排序  </p>
<p>当逆序对的数量极少时，插入排序的效率特别高 甚至速度比 O nlogn    级别的快速排序还要快</p>
<p>数据量不是特别大的时候，插入排序的效率也是非常好的</p>
<h2 id="插入排序——优化"><a href="#插入排序——优化" class="headerlink" title="插入排序——优化"></a>插入排序——优化</h2><p><strong>原理：</strong></p>
<p> 思路是将【交换】转为【挪动】 </p>
<p>① 先将待插入的元素备份 </p>
<p>② 头部有序数据中比待插入元素大的，都朝尾部方向挪动1个位置</p>
<p>③ 将待插入元素放到最终的合适位置 </p>
<p><img src="/posts/2755965992.html/1628263489426-c7f1f69d-581c-4a9b-ba36-918d5182c7fd.png" alt="image.png"></p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = begin;</span><br><span class="line">            T v = array[cur];</span><br><span class="line">            <span class="keyword">while</span> (cur &gt; <span class="number">0</span> &amp;&amp; cmp(v, array[cur - <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                array[cur] = array[cur - <span class="number">1</span>];</span><br><span class="line">                cur--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[cur] = v;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序——二分搜索优化"><a href="#插入排序——二分搜索优化" class="headerlink" title="插入排序——二分搜索优化"></a>插入排序——二分搜索优化</h2><p>插入排序就像在已排列好的数据中，插入一个数值合适，位置合适的数，而我们寻找这个位置的时候就可以使用<strong>二分查找</strong>（在我的另一篇文章）来找到哪个合适的位置。</p>
<p><strong>原理：</strong></p>
<p>在元素 v 的插入过程中，可以先二分搜索出合适的插入位置，然后再将元素 v 插入 </p>
<p><img src="/posts/2755965992.html/1628269044438-3615a888-a711-423b-ae36-0431f7730a0f.png" alt="image.png"></p>
<p>要求二分搜索返回的插入位置：第1个大于 v 的元素位置</p>
<p>如果 v 是 5，返回 2；</p>
<p>如果 v 是 1，返回 0；</p>
<p>如果 v 是 15，返回 7 ；</p>
<p>如果 v 是 8，返回 5 </p>
<p>假设在 [begin, end) 范围内搜索某个元素 v，mid == (begin + end) /2 </p>
<p>如果 v &lt; m，去 [begin, mid) 范围内二分搜索 </p>
<p>如果 v ≥ m，去 [mid + 1, end) 范围内二分搜索 </p>
<p><img src="/posts/2755965992.html/1628269191271-63deb3aa-b08d-4374-85b1-d39fe31781f0.png" alt="image.png"></p>
<p><img src="/posts/2755965992.html/1628269243699-6e5e2be4-33e6-4f6f-913a-bfe253183b32.png" alt="image.png"><img src="/posts/2755965992.html/1628269260394-b1b3d795-c55e-48f6-a4f5-f8248cf875ac.png" alt="image.png"></p>
<p><img src="/posts/2755965992.html/1628269351051-cbed6358-5c92-482d-b2c9-571a3dc60395.png" alt="image.png"></p>
<p><img src="/posts/2755965992.html/1628269396070-690ddbe3-f4aa-4e60-adfb-5eae94aaafa7.png" alt="image.png"></p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin = <span class="number">1</span>; begin &lt; array.length; begin++) &#123;</span><br><span class="line">            insert(begin, search(begin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将source位置的元素插入到dest位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dest</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> source, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">        T v = array[source];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = source; i &gt; dest; i--) &#123;</span><br><span class="line">            array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        array[dest] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用二分搜索找到 index 位置元素的待插入位置</span></span><br><span class="line"><span class="comment">     * 已经排好序数组的区间范围是 [0, index)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = index;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (cmp(array[index], array[mid]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p>需要注意的是，使用了二分搜索后，只是减少了比较次数，但插入排序的平均时间复杂度依然是 O(n2) ；</p>
<p>我们只是在原有的复杂度上在查找合适位置时，进行了优化原有的时间复杂度没有变化。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>堆排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序3</title>
    <url>/posts/1489199829.html/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>前言：</strong></p>
<p>快速排序相较于之前的排序方法是一种比较特别排序方法</p>
<p><strong>原理：</strong></p>
<p>1、从序列中选择一个轴点元素（pivot） 假设每次选择 0 位置的元素为轴点元素 ；</p>
<p>2、利用 pivot 将序列分割成 2 个子序列 将小于 pivot 的元素放在pivot前面（左侧） 将大于 pivot 的元素放在pivot后面（右侧） 等于pivot的元素放哪边都可以 </p>
<p>3、对子序列进行 1、2、 操作 直到不能再分割（子序列中只剩下1个元素）</p>
<p><img src="/posts/1489199829.html/1628353377907-1868ad9a-a881-40fc-bc33-b787e897a661.png" alt="image.png"></p>
<p>快速排序的本质：逐渐将每一个元素都转换成轴点元素</p>
<h2 id="快速排序-–-轴点构造"><a href="#快速排序-–-轴点构造" class="headerlink" title="快速排序 – 轴点构造"></a>快速排序 – 轴点构造</h2><p><img src="/posts/1489199829.html/1628353501143-ea4ac142-6da8-443c-aae7-fff6ad9a3929.png" alt="image.png"></p>
<p>一个轴点完成之后，数组被分割成两部分，我们就可以构造成一个前轴点，和一个后轴点；以此类推，当每个元素都成为轴点之后，数组排列完成。</p>
<p>*<strong>示例：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void sort() &#123;</span><br><span class="line">        sort(0, array.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对 [begin, end) 范围的元素进行快速排序</span><br><span class="line">     * @param begin</span><br><span class="line">     * @param end</span><br><span class="line">     */</span><br><span class="line">    private void sort(int begin, int end) &#123; </span><br><span class="line">        if (end - begin &lt; 2) return;</span><br><span class="line">        </span><br><span class="line">        // 确定轴点位置 O(n)</span><br><span class="line">        int mid = pivotIndex(begin, end);</span><br><span class="line">        // 对子序列进行快速排序</span><br><span class="line">        sort(begin, mid); </span><br><span class="line">        sort(mid + 1, end); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 构造出 [begin, end) 范围的轴点元素</span><br><span class="line">     * @return 轴点元素的最终位置</span><br><span class="line">     */</span><br><span class="line">    private int pivotIndex(int begin, int end) &#123;</span><br><span class="line">        // 随机选择一个元素跟begin位置进行交换</span><br><span class="line">        swap(begin, begin + (int)(Math.random() * (end - begin)));</span><br><span class="line">        </span><br><span class="line">        // 备份begin位置的元素</span><br><span class="line">        T pivot = array[begin];</span><br><span class="line">        // end指向最后一个元素</span><br><span class="line">        end--;</span><br><span class="line">        //这里是一个很神奇的交替循环方式，不过还是比较好用的</span><br><span class="line">        //如果大家有更好的方法可以评论</span><br><span class="line">        while (begin &lt; end) &#123;</span><br><span class="line">            while (begin &lt; end) &#123;</span><br><span class="line">                if (cmp(pivot, array[end]) &lt; 0) &#123; // 右边元素 &gt; 轴点元素</span><br><span class="line">                    end--;</span><br><span class="line">                &#125; else &#123; // 右边元素 &lt;= 轴点元素</span><br><span class="line">                    array[begin++] = array[end];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (begin &lt; end) &#123;</span><br><span class="line">                if (cmp(pivot, array[begin]) &gt; 0) &#123; // 左边元素 &lt; 轴点元素</span><br><span class="line">                    begin++;</span><br><span class="line">                &#125; else &#123; // 左边元素 &gt;= 轴点元素</span><br><span class="line">                    array[end--] = array[begin];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将轴点元素放入最终的位置</span><br><span class="line">        array[begin] = pivot;</span><br><span class="line">        // 返回轴点元素的位置</span><br><span class="line">        return begin;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p><img src="/posts/1489199829.html/1628354600150-c0bdfa64-7683-4954-8498-ba5f81ce756a.png" alt="`3%ML8W`D70YE~HAAS9BK8X.png"></p>
<h2 id="快速排序-–-与轴点相等的元素"><a href="#快速排序-–-与轴点相等的元素" class="headerlink" title="快速排序 – 与轴点相等的元素"></a>快速排序 – 与轴点相等的元素</h2><p><img src="/posts/1489199829.html/1628354720337-95d1ac45-2216-494d-b2b7-39a1add80e90.png" alt="image.png"></p>
<p>如果序列中的所有元素都与轴点元素相等，利用目前的算法实现，轴点元素可以将序列分割成 2 个均匀的子序列 </p>
<p><img src="/posts/1489199829.html/1628354762652-c63f4bbc-9316-4619-afed-e72c40bbaeda.png" alt="image.png"></p>
<p>我们利用if else 中else实现了如果其他元素与轴点相等的情况，但是如果将其中’&lt;’或’&gt;’修改成’&lt;=’或’&gt;=’这种情况呢？</p>
<p><img src="/posts/1489199829.html/1628354947961-41a55c99-83bc-4432-960e-5b3bbcf01f1c.png" alt="image.png"></p>
<p>导致的结果是显而易见，他会造成轴点元素切割出来的子序列极度不均匀，从而影响了效率，导致出现最坏的时间复杂度.</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>前言：</strong></p>
<p>总感觉希尔排序就像归并的那种感觉，但是！他的原理就像插入排序一样，在不断减少逆序对进行排序</p>
<p><strong>原理：</strong></p>
<p>希尔排序把序列看作是一个矩阵，分成 𝑚 列，逐列进行排序 </p>
<p>𝑚 从某个整数逐渐减为1 </p>
<p>当 𝑚 为1时，整个序列将完全有序  </p>
<p>因此，希尔排序也被称为递减增量排序（Diminishing Increment Sort）  </p>
<p>矩阵的列数取决于步长序列（step sequence） </p>
<p>比如，如果步长序列为{1,5,19,41,109,…}，就代表依次分成109列、41列、19列、5列、1列进行排序 </p>
<p>不同的步长序列，执行效率也不同 </p>
<p>希尔本人给出的步长序列是 𝑛/2𝑘，比如 𝑛 为16时，步长序列是{1, 2, 4, 8} </p>
<p><img src="/posts/1489199829.html/1628435708290-feb47ecc-6c04-41d6-b010-4d73963fa9cc.png" alt="image.png"></p>
<p>分成8列进行排序</p>
<p><img src="/posts/1489199829.html/1628435771749-764b3a5b-556b-4df4-9231-b54094bc981b.png" alt="image.png"></p>
<p>分成4列进行排序</p>
<p><img src="/posts/1489199829.html/1628435818477-1defd585-9992-4077-91a2-e1d60fe0326c.png" alt="image.png"></p>
<p>分成2列进行排序</p>
<p><img src="/posts/1489199829.html/1628435849108-f5ffa812-c6bc-4a2e-9fbe-f9bf6f7e90f6.png" alt="image.png"></p>
<p>分成1列进行排序</p>
<p><img src="/posts/1489199829.html/1628435876039-baba66db-3ec1-4581-a818-e6b4e088e485.png" alt="image.png"></p>
<p>不难看出来，从8列 变为 1列的过程中，逆序对的数量在逐渐减少；因此希尔排序底层一般使用插入排序对每一列进行排序，也很多资料认为希尔排序是插入排序的改进版</p>
<p><strong>*示例：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void sort() &#123;</span><br><span class="line">    //选择不长序列，后面会讲到</span><br><span class="line">        List&lt;Integer&gt; stepSequence = sedgewickStepSequence();</span><br><span class="line">    //循环使用步长序列排序</span><br><span class="line">        for (Integer step : stepSequence) &#123;</span><br><span class="line">            sort(step);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 分成step列进行排序</span><br><span class="line">     */</span><br><span class="line">    private void sort(int step) &#123;</span><br><span class="line">        // col : 第几列，column的简称</span><br><span class="line">        for (int col = 0; col &lt; step; col++) &#123; // 对第col列进行排序</span><br><span class="line">            // col、col+step、col+2*step、col+3*step</span><br><span class="line">            for (int begin = col + step; begin &lt; array.length; begin += step) &#123;</span><br><span class="line">                int cur = begin;</span><br><span class="line">                while (cur &gt; col &amp;&amp; cmp(cur, cur - step) &lt; 0) &#123;</span><br><span class="line">                    swap(cur, cur - step);</span><br><span class="line">                    cur -= step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //希尔提供的步长序列</span><br><span class="line">    private List&lt;Integer&gt; shellStepSequence() &#123;</span><br><span class="line">        List&lt;Integer&gt; stepSequence = new ArrayList&lt;&gt;();</span><br><span class="line">        int step = array.length;</span><br><span class="line">        while ((step &gt;&gt;= 1) &gt; 0) &#123;</span><br><span class="line">            stepSequence.add(step);</span><br><span class="line">        &#125;</span><br><span class="line">        return stepSequence;</span><br><span class="line">    &#125;</span><br><span class="line">    //目前最好的步长序列</span><br><span class="line">    private List&lt;Integer&gt; sedgewickStepSequence() &#123;</span><br><span class="line">        List&lt;Integer&gt; stepSequence = new LinkedList&lt;&gt;();</span><br><span class="line">        int k = 0, step = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (k % 2 == 0) &#123;</span><br><span class="line">                int pow = (int) Math.pow(2, k &gt;&gt; 1);</span><br><span class="line">                step = 1 + 9 * (pow * pow - pow);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int pow1 = (int) Math.pow(2, (k - 1) &gt;&gt; 1);</span><br><span class="line">                int pow2 = (int) Math.pow(2, (k + 1) &gt;&gt; 1);</span><br><span class="line">                step = 1 + 8 * pow1 * pow2 - 6 * pow2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (step &gt;= array.length) break;</span><br><span class="line">            stepSequence.add(0, step);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        return stepSequence;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序——步长序列"><a href="#希尔排序——步长序列" class="headerlink" title="希尔排序——步长序列"></a>希尔排序——步长序列</h2><p>希尔排序中最灵魂的地方可能就是步长序列了吧</p>
<p>希尔排序是利用步长序列来分割原序列，而每次分割，都会影响排序的复杂度，而目前已知的最好的步长序列，最坏情况时间复杂度是 O(n4/3) ，1986年由Robert Sedgewick提出 </p>
<p><img src="/posts/1489199829.html/1628437057030-81332644-22ae-4f96-acd3-7bcbef28ab89.png" alt="image.png"></p>
<p><strong>*示例：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;Integer&gt; sedgewickStepSequence() &#123;</span><br><span class="line">        List&lt;Integer&gt; stepSequence = new LinkedList&lt;&gt;();</span><br><span class="line">        int k = 0, step = 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (k % 2 == 0) &#123;</span><br><span class="line">                int pow = (int) Math.pow(2, k &gt;&gt; 1);</span><br><span class="line">                step = 1 + 9 * (pow * pow - pow);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int pow1 = (int) Math.pow(2, (k - 1) &gt;&gt; 1);</span><br><span class="line">                int pow2 = (int) Math.pow(2, (k + 1) &gt;&gt; 1);</span><br><span class="line">                step = 1 + 8 * pow1 * pow2 - 6 * pow2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (step &gt;= array.length) break;</span><br><span class="line">            stepSequence.add(0, step);</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        return stepSequence;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/posts/872565161.html/</url>
    <content><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]</p>
<p>输出: true</p>
<p>示例 2:</p>
<p>输入: [1,2,3,4]</p>
<p>输出: false</p>
<p>示例 3:</p>
<p>输入: [1,1,1,3,3,4,3,2,4,2]</p>
<p>输出: true</p>
<p><strong>排序</strong></p>
<p>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsDuplicate(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">            if (nums[i] == nums[i + 1]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>哈希表</strong></p>
<p>对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsDuplicate(int[] nums) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            if (!set.add(x)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：做这道题的时候看到的是查找重复的元素，就直接想到了哈希表，没有想到还有排序的这种解法</p>
<h1 id="最大的子序和"><a href="#最大的子序和" class="headerlink" title="最大的子序和"></a>最大的子序和</h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例 1：</p>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</p>
<p>输出：6</p>
<p>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
<p>示例 2：</p>
<p>输入：nums = [1]</p>
<p>输出：1</p>
<p>示例 3：</p>
<p>输入：nums = [0]</p>
<p>输出：0</p>
<p>示例 4：</p>
<p>输入：nums = [-1]</p>
<p>输出：-1</p>
<p>示例 5：</p>
<p>输入：nums = [-100000]</p>
<p>输出：-100000</p>
<p><strong>动态规划：</strong></p>
<p>下面的解法是用动态规划的思想来做的，以后也会写一篇关于动态规划的专题，看了很多的讲解还是不能很好地理解，后来看到评论区中大神d而一句话：“之前数值所有的和加上自身，还没有我自己大，我要他干啥”看到这句话之后的我幡然醒悟。</p>
<p>pre是用来存储之前数值和加上自身的值，maxAns是用来维护最大子序和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, maxAns = nums[0];</span><br><span class="line">        for (int x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>排序4</title>
    <url>/posts/3332896630.html/</url>
    <content><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p><strong>前言：</strong></p>
<p>这是一种不需要比较的排序方式，但极其浪费空间。（写嵌入式的小伙伴会气死吧）</p>
<p><strong>原理：</strong></p>
<p>统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引</p>
<p><img src="/posts/3332896630.html/1628443378045-18531bd2-4697-4e8a-908c-c2da8ff65033.png" alt="image.png"></p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这是最简单的实现方式</span><br><span class="line"> </span><br><span class="line">// 找出最大值</span><br><span class="line">        int max = array[0];</span><br><span class="line">        for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            if (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; // O(n)</span><br><span class="line">        </span><br><span class="line">        // 开辟内存空间，存储每个整数出现的次数</span><br><span class="line">        int[] counts = new int[1 + max];</span><br><span class="line">        // 统计每个整数出现的次数</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            counts[array[i]]++;</span><br><span class="line">        &#125; // O(n)</span><br><span class="line">        </span><br><span class="line">        // 根据整数的出现次数，对整数进行排序</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int i = 0; i &lt; counts.length; i++) &#123;</span><br><span class="line">            while (counts[i]-- &gt; 0) &#123;</span><br><span class="line">                array[index++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; // O(n)</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<p>这个版本的实现存在以下问题：无法对负整数进行排序；极其浪费内存空间；是个不稳定的排序 。</p>
<p>（用这个的人就很神奇）</p>
<h2 id="计数排序-–-改进思路"><a href="#计数排序-–-改进思路" class="headerlink" title="计数排序 – 改进思路"></a>计数排序 – 改进思路</h2><p>原本我们是把数组的索引作为记录原序列中的数值，但是数组中没有负数，所以我们就没有办法比较序列中的负数。</p>
<p>现在我们将数组中第一个位置就是序列中最小的数，利用这个数和数组索引的差，</p>
<p><img src="/posts/3332896630.html/1628502501716-0b0fab4a-528f-4371-8956-5911b2b69299.png" alt="image.png"></p>
<p>解决的不能负数的问题，现在来解决不稳定</p>
<p><img src="/posts/3332896630.html/1628504775294-927e1ec9-5d2f-4616-9136-aef799f1bb1f.png" alt="image.png"></p>
<p>假设array中的最小值是 min； array中的元素 k 对应的 counts 索引是 k – min； array中的元素 k 在有序序列中的索引； counts[k – min] – p； p 代表着是倒数第几个 k； </p>
<p><img src="/posts/3332896630.html/1628504893826-410f34bf-89fe-4f9c-a60c-c38162ecd423.png" alt="image.png"></p>
<p><img src="/posts/3332896630.html/1628504906903-6b638877-9008-431e-92d8-9497c162ded5.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 找出最值</span><br><span class="line">        int max = array[0];</span><br><span class="line">        int min = array[0];</span><br><span class="line">        for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            if (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if (array[i] &lt; min) &#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 开辟内存空间，存储次数</span><br><span class="line">        int[] counts = new int[max - min + 1];</span><br><span class="line">        // 统计每个整数出现的次数</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            counts[array[i] - min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 累加次数</span><br><span class="line">        for (int i = 1; i &lt; counts.length; i++) &#123;</span><br><span class="line">            counts[i] += counts[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 从后往前遍历元素，将它放到有序数组中的合适位置</span><br><span class="line">        int[] newArray = new int[array.length];</span><br><span class="line">        for (int i = array.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            newArray[--counts[array[i] - min]] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将有序数组赋值到array</span><br><span class="line">        for (int i = 0; i &lt; newArray.length; i++) &#123;</span><br><span class="line">            array[i] = newArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p><strong>前言：</strong></p>
<p>基数排序，所谓的基数就是他的个位，十位，百位，通过个十百千的顺序依次排列各位的数字大小，最后得到所有数字的大小。</p>
<p><strong>原理：</strong></p>
<p>基数排序非常适合用于整数排序（尤其是非负整数），因此只演示对非负整数进行基数排序 执行流程：依次对个位数、十位数、百位数、千位数、万位数…进行排序（从低位到高位）</p>
<p><img src="/posts/3332896630.html/1628525299836-3c0692cc-ae6d-4646-b9e6-2799e1b80f75.png" alt="image.png"></p>
<p>对位数排序时，我们使用计数排序</p>
<p><strong>*示例：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 找出最大值</span><br><span class="line">        int max = array[0];</span><br><span class="line">        for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            if (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 个位数: array[i] / 1 % 10 = 3</span><br><span class="line">        // 十位数：array[i] / 10 % 10 = 9</span><br><span class="line">        // 百位数：array[i] / 100 % 10 = 5</span><br><span class="line">        // 千位数：array[i] / 1000 % 10 = ...</span><br><span class="line"></span><br><span class="line">        for (int divider = 1; divider &lt;= max; divider *= 10) &#123;</span><br><span class="line">            countingSort(divider);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">protected void countingSort(int divider) &#123;</span><br><span class="line">        // 开辟内存空间，存储次数</span><br><span class="line">        int[] counts = new int[10];</span><br><span class="line">        // 统计每个整数出现的次数</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            counts[array[i] / divider % 10]++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 累加次数</span><br><span class="line">        for (int i = 1; i &lt; counts.length; i++) &#123;</span><br><span class="line">            counts[i] += counts[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 从后往前遍历元素，将它放到有序数组中的合适位置</span><br><span class="line">        int[] newArray = new int[array.length];</span><br><span class="line">        for (int i = array.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            newArray[--counts[array[i] / divider % 10]] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将有序数组赋值到array</span><br><span class="line">        for (int i = 0; i &lt; newArray.length; i++) &#123;</span><br><span class="line">            array[i] = newArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序-–-另一种思路"><a href="#基数排序-–-另一种思路" class="headerlink" title="基数排序 – 另一种思路"></a>基数排序 – 另一种思路</h2><p>我们先按照个位数的大小竖着放起来</p>
<p><img src="/posts/3332896630.html/1628526998097-1d4fac61-723a-4ef6-bf58-5d56b4405973.png" alt="image.png"></p>
<p>然后，我们依次将数穿起来，最后，就会把数列排好</p>
<p><strong>*示例：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 找出最大值</span><br><span class="line">        int max = array[0];</span><br><span class="line">        for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            if (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //用来记录的二维数组</span><br><span class="line">        int buckets[][]=new int[10][array.length];</span><br><span class="line">        //二维数组每列的数量</span><br><span class="line">        int bucketSizes[]=new int[buckets.length];</span><br><span class="line"></span><br><span class="line">        for (int divider = 1; divider &lt;= max; divider *= 10)&#123;</span><br><span class="line">            for (int i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">                int a=array[i] / divider % 10;</span><br><span class="line">                buckets[a][bucketSizes[a]++]=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            int index=0;</span><br><span class="line">            for (int i=0;i&lt;buckets.length;i++)&#123;</span><br><span class="line">                for (int j=0;j&lt;bucketSizes[i];j++)&#123;</span><br><span class="line">                    array[index++]=buckets[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                bucketSizes[i]=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈贪心算法</title>
    <url>/posts/3209966166.html/</url>
    <content><![CDATA[<p>本篇文章是利用了简单的例题，对贪心算法进行理解，并没有用到特别难的题，只是单独的利用了贪心算法，后续会对贪心算法进行例题式详解</p>
<p>含义： 贪心策略，也称为贪婪策略 每一步都采取当前状态下最优的选择（局部最优解），从而希望推导出全局最优解</p>
<p>贪心的应用：</p>
<p>哈夫曼树 </p>
<p>最小生成树算法：Prim、Kruskal </p>
<p>最短路径算法：Dijkstra </p>
<h1 id="最优装载问题（加勒比海盗）"><a href="#最优装载问题（加勒比海盗）" class="headerlink" title="最优装载问题（加勒比海盗）"></a>最优装载问题（加勒比海盗）</h1><p>题目：</p>
<p>在北美洲东南部，有一片神秘的海域，是海盗最活跃的加勒比海 有一天，海盗们截获了一艘装满各种各样古董的货船，每一件古董都价值连城，一旦打碎就失去了它的价值 </p>
<p>海盗船的载重量为 W，每件古董的重量为 𝑤i，海盗们该如何把尽可能多数量的古董装上海盗船？ </p>
<p>比如 W 为 30，𝑤i 分别为 3、5、4、10、7、14、2、11</p>
<p>贪心策略：每一次都优先选择重量最小的古董 </p>
<p>① 选择重量为 2 的古董，剩重量 28 </p>
<p>② 选择重量为 3 的古董，剩重量 25 </p>
<p>③ 选择重量为 4 的古董，剩重量 21</p>
<p>④ 选择重量为 5 的古董，剩重量 16 </p>
<p>⑤ 选择重量为 7 的古董，剩重量 9 </p>
<p>最多能装载 5 个古董 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int[] weights = &#123;3, 5, 4, 10, 7, 14, 2, 11&#125;;</span><br><span class="line">        Arrays.sort(weights);</span><br><span class="line">        int capacity = 30, weight = 0, count = 0;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; weights.length &amp;&amp; weight &lt; capacity; i++) &#123;</span><br><span class="line">            int newWeight = weight + weights[i];</span><br><span class="line">            if (newWeight &lt;= capacity) &#123;</span><br><span class="line">                weight = newWeight;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(weights[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;一共选了&quot; + count + &quot;件古董&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p>题目：</p>
<p>假设有 25 分、10 分、5 分、1 分的硬币，现要找给客户 41 分的零钱，如何办到硬币个数最少？ </p>
<p>贪心策略：每一次都优先选择面值最大的硬币 </p>
<p>① 选择 25 分的硬币，剩 16 分 </p>
<p>② 选择 10 分的硬币，剩 6 分 </p>
<p>③ 选择 5 分的硬币，剩 1 分 </p>
<p>④ 选择 1 分的硬币 </p>
<p>最终的解是共 4 枚硬币 25 分、10 分、5 分、1 分硬币各一枚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int[] a=&#123;25,5,10,1&#125;;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        int money=50;</span><br><span class="line">        int coins=0;</span><br><span class="line">        for(int i=a.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">            if(money&lt;a[i])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            money-=a[i];</span><br><span class="line">            i++;</span><br><span class="line">            coins++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(coins);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="另一种方式的零钱兑换"><a href="#另一种方式的零钱兑换" class="headerlink" title="另一种方式的零钱兑换"></a>另一种方式的零钱兑换</h2><p>题目：</p>
<p>假设有 25 分、20 分、5 分、1 分的硬币，现要找给客户 41 分的零钱，如何办到硬币个数最少？ </p>
<p>贪心策略：每一步都优先选择面值最大的硬币 </p>
<p>① 选择 25 分的硬币，剩 16 分 </p>
<p>② 选择 5 分的硬币，剩 11 分 </p>
<p>③ 选择 5 分的硬币，剩 6 分 </p>
<p>④ 选择 5 分的硬币，剩 1 分 </p>
<p>⑤ 选择 1 分的硬币 </p>
<p>最终的解是 1 枚 25 分、3 枚 5 分、1 枚 1 分的硬币，共 5 枚硬币</p>
<p>实际上本题的最优解是：2 枚 20 分、1 枚 1 分的硬币，共 3 枚硬币</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>贪心策略并不一定能得到全局最优解 </p>
<p>因为一般没有测试所有可能的解，容易过早做决定，所以没法达到最佳解 </p>
<p>贪图眼前局部的利益最大化，看不到长远未来，走一步看一步  优点：简单、高效、不需要穷举所有可能，通常作为其他算法的辅助算法来使用  </p>
<p>缺点：鼠目寸光，不从整体上考虑其他可能，每次采取局部最优解，不会再回溯，因此很少情况会得到最优解 </p>
<p><strong>其实我们多数关于贪心算法的题解并不是单单只用了贪心算法，多数都会搭配上动态数组来进行配合解题</strong></p>
<h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h1><p>问题：</p>
<p>有 n 件物品和一个最大承重为 W 的背包，每件物品的重量是 𝑤i、价值是 𝑣i </p>
<p>在保证总重量不超过 W 的前提下，将哪几件物品装入背包，可以使得背包的总价值最大？ </p>
<p>注意：每个物品只有 1 件，也就是每个物品只能选择 0 件或者 1 件，因此称为 0-1背包问题</p>
<p>如果采取贪心策略，有3个方案 </p>
<p>① 价值主导：优先选择价值最高的物品放进背包 </p>
<p>② 重量主导：优先选择重量最轻的物品放进背包 </p>
<p>③ 价值密度主导：优先选择价值密度最高的物品放进背包（价值密度 = 价值 ÷ 重量）</p>
<p><img src="/posts/3209966166.html/1629304811500-244cd73d-9667-420f-b8a3-cb74ab511cdf.png" alt="image.png"></p>
<p>因为不是在<strong>leetcode</strong>中直接做题，所以我们做题前需要实现一个实体类</p>
<p><em><strong>示例：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//存储物品的实体类  </span><br><span class="line">public class Article &#123;</span><br><span class="line">    public int weight;</span><br><span class="line">    public int value;</span><br><span class="line">    public double valueDensity;</span><br><span class="line">    public Article(int weight, int value) &#123;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">        this.value = value;</span><br><span class="line">        valueDensity = value * 1.0 / weight;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Article [weight=&quot; + weight + &quot;, value=&quot; + value + &quot;, valueDensity=&quot; + valueDensity + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现类</span><br><span class="line">public class Knapsack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        select(&quot;价值主导&quot;, (Article a1, Article a2) -&gt; &#123;</span><br><span class="line">            return a2.value - a1.value;</span><br><span class="line">        &#125;);</span><br><span class="line">        select(&quot;重量主导&quot;, (Article a1, Article a2) -&gt; &#123;</span><br><span class="line">            return a1.weight - a2.weight;</span><br><span class="line">        &#125;);</span><br><span class="line">        select(&quot;价值密度主导&quot;, (Article a1, Article a2) -&gt; &#123;</span><br><span class="line">            return Double.compare(a2.valueDensity, a1.valueDensity);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void select(String title, Comparator&lt;Article&gt; cmp) &#123;</span><br><span class="line">        Article[] articles = new Article[] &#123;</span><br><span class="line">            new Article(35, 10), new Article(30, 40),</span><br><span class="line">            new Article(60, 30), new Article(50, 50),</span><br><span class="line">            new Article(40, 35), new Article(10, 40),</span><br><span class="line">            new Article(25, 30)</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(articles, cmp);</span><br><span class="line">        </span><br><span class="line">        int capacity = 150, weight = 0, value = 0;</span><br><span class="line">        List&lt;Article&gt; selectedArticles = new LinkedList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; articles.length &amp;&amp; weight &lt; capacity; i++) &#123;</span><br><span class="line">            int newWeight = weight + articles[i].weight;</span><br><span class="line">            if (newWeight &lt;= capacity) &#123;</span><br><span class="line">                weight = newWeight;</span><br><span class="line">                value += articles[i].value;</span><br><span class="line">                selectedArticles.add(articles[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;【&quot; + title + &quot;】&quot;);</span><br><span class="line">        System.out.println(&quot;总价值：&quot; + value);</span><br><span class="line">        for (int i = 0; i &lt; selectedArticles.size(); i++) &#123;</span><br><span class="line">            System.out.println(selectedArticles.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;-----------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在实现类中用到了选择器，既然说到了，我们学习一下（有空肯定补）</p>
<p>本文代码均可进行复制粘贴到编译器，后进行debug，来了解代码运行过程</p>
<p>有问题可进行留言，博主看后回复</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网路互通模型</title>
    <url>/posts/37276003.html/</url>
    <content><![CDATA[<p>为了更好地促进互联网络的研究和发展，国际标准化组织 ISO 在 1985 年制定了网络互连模型 OSI 参考模型（Open System Interconnect Reference Model），具有 7 层结构 </p>
<p><img src="/posts/37276003.html/1629274873953-4ab62fa1-4597-4129-a9aa-b8b420a390d0.png" alt="image.png"></p>
<p><img src="/posts/37276003.html/1629274904417-00c8f27e-cc35-411d-a3da-7c4218e1bc24.png" alt="image.png"></p>
<p><img src="/posts/37276003.html/1629274915186-6a60454f-b6ba-4ba1-ba85-ea3754833548.png" alt="image.png"></p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层定义了接口标准、线缆标准、传输速率、传输方式等 </p>
<p><img src="/posts/37276003.html/1629275395892-2d3843a2-ebaa-4ebd-b035-2d4498da3c3c.png" alt="image.png"></p>
<h2 id="数字信号、模拟信号"><a href="#数字信号、模拟信号" class="headerlink" title="数字信号、模拟信号"></a>数字信号、模拟信号</h2><p><img src="/posts/37276003.html/1629275471400-7439f102-fb8d-4f4f-846e-7685cb28710b.png" alt="image.png"></p>
<p>模拟信号（Analog Signal） </p>
<p>连续的信号，适合长距离传输 </p>
<p>抗干扰能力差，受到干扰时波形变形很难纠正</p>
<p> 数字信号（Digital Signal） </p>
<p>离散的信号，不适合长距离传输 </p>
<p>抗干扰能力强，受到干扰时波形失真可以修复</p>
<h2 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h2><p>局域网通信模型 </p>
<p><img src="/posts/37276003.html/1629275540060-92a34d2e-c83e-4f0e-80b2-a978ca4fb294.png" alt="image.png"></p>
<p>广域网通信模型 </p>
<p><img src="/posts/37276003.html/1629275554344-2f244478-f2e8-4763-adb2-a6300568894c.png" alt="image.png"></p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道：信息传输的通道，一条传输介质上（比如网线）上可以有多条信道  </p>
<p>单工通信 </p>
<p>信号只能往一个方向传输，任何时候都不能改变信号的传输方向 </p>
<p>比如无线电广播、有线电视广播</p>
<p>半双工通信 </p>
<p>信号可以双向传输，但必须是交替进行，同一时间只能往一个方向传输 </p>
<p>比如对讲机</p>
<p>全双工通信 </p>
<p>信号可以同时双向传输 </p>
<p>比如手机（打电话，听说同时进行）</p>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>链路：从1个节点到相邻节点的一段物理线路（有线或无线），中间没有其他交换节点   </p>
<p><img src="/posts/37276003.html/1629275693272-8cdc9760-1c42-437d-a565-98004aa51f10.png" alt="image.png"></p>
<p>数据链路：在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输 </p>
<p>不同类型的数据链路，所用的通信协议可能是不同的</p>
<p>广播信道：CSMA/CD协议（比如同轴电缆、集线器等组成的网络） </p>
<p>点对点信道：PPP协议（比如2个路由器之间的信道）</p>
<p>数据链路层的3个基本问题：封装成帧、透明传输、差错检验</p>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p><img src="/posts/37276003.html/1629275755003-5a50c572-3ee5-4b37-a931-ce4655355308.png" alt="image.png"></p>
<p> 帧（Frame）的数据部分 </p>
<p>就是网络层传递下来的数据包（IP数据包，Packet）</p>
<p>最大传输单元MTU（Maximum Transfer Unit） </p>
<p>每一种数据链路层协议都规定了所能够传送的帧的数据长度上限 </p>
<p>以太网的MTU为1500个字节</p>
<h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p><img src="/posts/37276003.html/1629275822174-5bc265d1-9396-4806-9282-5328499777f4.png" alt="image.png"></p>
<p>使用SOH（Start Of Header）作为帧开始符  </p>
<p>使用EOT（End Of Transmission）作为帧结束符 </p>
<p>数据部分一旦出现了SOH、EOT，就需要进行转义 </p>
<p><img src="/posts/37276003.html/1629275851191-2b5f03d7-807c-474b-96cb-f10ab9fa379d.png" alt="image.png"></p>
<h2 id="差错检验"><a href="#差错检验" class="headerlink" title="差错检验"></a>差错检验</h2><p><img src="/posts/37276003.html/1629275862616-8dbe1294-4690-4206-93a8-49480e7b58f4.png" alt="image.png"></p>
<p>FCS是根据数据部分 + 首部计算得出的 </p>
<h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p>CSMA/CD（Carrier Sense Multiple Access with Collision Detectio） </p>
<p>载波侦听多路访问/冲突检测</p>
<p>使用了CSMA/CD的网络可以称为是以太网（Ethernet），它传输的是以太网帧 </p>
<p>以太网帧的格式有：Ethernet V2标准、IEEE的802.3标准 </p>
<p>使用最多的是：Ethernet V2标准</p>
<p>为了能够检测正在发送的帧是否产生了冲突，以太网的帧至少要64字节  </p>
<p>用交换机组建的网络，已经支持全双工通信，不需要再使用CSMA/CD，但它传输的帧依然是以太网帧 </p>
<p>所以，用交换机组建的网络，依然可以叫做以太网</p>
<h4 id="Ethernet-V2"><a href="#Ethernet-V2" class="headerlink" title="Ethernet V2"></a>Ethernet V2</h4><p><strong>帧格式</strong></p>
<p><img src="/posts/37276003.html/1629276026650-da94307e-978b-4567-b096-289fe5dfc85a.png" alt="image.png"></p>
<p>首部：目标MAC +源MAC + 网络类型 </p>
<p>以太网帧：首部 + 数据 + FCS</p>
<p>数据的长度至少是：64 – 6 – 6 – 2 – 4 = 46字节 </p>
<p><strong>标准</strong></p>
<p>当数据部分的长度小于46字节时 </p>
<p>数据链路层会在数据的后面加入一些字节填充 </p>
<p>接收端会将添加的字节去掉</p>
<p><img src="/posts/37276003.html/1629276108819-bfe191bd-1ac7-44a5-8512-868f672bbdf7.png" alt="image.png"></p>
<p>长度总结 </p>
<p>以太网帧的数据长度：46~1500字节 </p>
<p>以太网帧的长度：64~1518字节（目标MAC +源MAC + 网络类型 + 数据 + FCS）</p>
<h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p><img src="/posts/37276003.html/1629276158545-c047adcb-4f3a-4bce-a253-e3eb67b4df04.png" alt="image.png"></p>
<p>网卡接收到一个帧，首先会进行差错校验，如果校验通过则接收，否则丢弃 </p>
<p>Wireshark抓到的帧没有FCS ，因为它抓到的是差错校验通过的帧（帧尾的FCS会被硬件去掉） </p>
<p>Wireshark抓不到差错校验失败的帧 </p>
<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p><img src="/posts/37276003.html/1629276199348-62b632f6-1175-448f-b0e5-a08720098752.png" alt="image.png"></p>
<p>Address字段：图中的值是0xFF，形同虚设，点到点信道不需要源MAC、目标MAC地址 </p>
<p>Control字段：图中的值是0x03，目前没有什么作用 </p>
<p>Protocol字段：内部用到的协议类型 </p>
<p>帧开始符、帧结束符：0x7E </p>
<p><strong>字节填充</strong></p>
<p><strong><img src="/posts/37276003.html/1629276231722-c6eaf22b-eb36-4b80-b044-65cd8aa2621b.png" alt="image.png"></strong></p>
<p>将0x7E替换成0x7D5E </p>
<p>将0x7D替换成0x7D5D</p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基本概念</title>
    <url>/posts/1471950494.html/</url>
    <content><![CDATA[<h1 id="必知必会"><a href="#必知必会" class="headerlink" title="必知必会"></a>必知必会</h1><p><img src="/posts/1471950494.html/1628772576324-178a7943-a30e-476a-8ef0-74f635bdb290.png" alt="image.png"></p>
<p><img src="/posts/1471950494.html/1628772587039-5bdc4101-4598-4a5c-9efb-563008c9f124.png" alt="image.png"></p>
<p><img src="/posts/1471950494.html/1628772598945-83950ce0-f450-4a31-a07f-d1189a710f21.png" alt="image.png"></p>
<h1 id="计算机之间的通信"><a href="#计算机之间的通信" class="headerlink" title="计算机之间的通信"></a>计算机之间的通信</h1><p>需要得知对方的IP地址</p>
<p>最终是根据MAC地址（网卡地址），输送数据到网卡，被网卡接收</p>
<p>如果网卡发现数据的目标MAC地址是自己，就会将数据传递给上一层进行处理 </p>
<p>如果网卡发现数据的目标MAC地址不是自己，就会将数据丢弃，不会传递给上一层进行处理 </p>
<h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><h3 id="最直接的方式——网线直连"><a href="#最直接的方式——网线直连" class="headerlink" title="最直接的方式——网线直连"></a>最直接的方式——网线直连</h3><p>需要用到交叉线（不是直通线）</p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="/posts/1471950494.html/1628772183243-05550d56-458a-4b5b-84dc-38eede5ba6b1.png" alt="image.png"></p>
<p>特点：</p>
<ul>
<li><ul>
<li><ul>
<li>半双工通信</li>
<li>容易冲突</li>
<li>不安全</li>
<li>某一点出问题整个通信瘫痪</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p><img src="/posts/1471950494.html/1628772360766-ae26eeb9-4ea7-4780-9823-ab22f33ca3aa.png" alt="image.png"></p>
<p><img src="/posts/1471950494.html/1628772364385-aced90a0-6da5-4d21-9ab9-d98f9716f0b5.png" alt="image.png"></p>
<p>特点：</p>
<ul>
<li><ul>
<li><ul>
<li>半双工通信</li>
<li>容易冲突</li>
<li>不安全</li>
<li>和同轴电缆一样没有智商</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p><img src="/posts/1471950494.html/1628772662337-7bb5de77-a8f7-48da-8f7c-5174f763eb61.png" alt="image.png"></p>
<p><img src="/posts/1471950494.html/1628772665539-b40d3242-e23f-42a4-98fb-f0d0e74d7d6c.png" alt="image.png"></p>
<p>特点：</p>
<ul>
<li><ul>
<li><ul>
<li>能够通过自主学习得知网桥另一侧的MAC地址</li>
<li>能够起到隔绝冲突域的作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p><img src="/posts/1471950494.html/1628772767924-37ce9248-ca75-466c-a6cf-9f1864d537c2.png" alt="image.png"></p>
<p><img src="/posts/1471950494.html/1628772772054-9cb3cfbd-31a6-443f-92f0-e485787844ff.png" alt="image.png"><img src="/posts/1471950494.html/1628772776123-1974cef5-3a66-4a49-9c82-53709aebc81a.png" alt="image.png"></p>
<p>特点：</p>
<ul>
<li><ul>
<li><ul>
<li>相当于更多接口的网桥</li>
<li>全双工通信</li>
<li>比集线器更安全</li>
</ul>
</li>
</ul>
</li>
<li><p>如果全球的互联网都使用交换机连接会发生什么事情？</p>
</li>
</ul>
<p>首先可能会产生IP地址不够用的，其次在最开始的时候需要通过ARP协议获取MAC地址，会产生广播风暴</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p><img src="/posts/1471950494.html/1628786349778-a69989dc-b0fe-4e97-afa8-40e3fa1fdba7.png" alt="image.png"></p>
<p><img src="/posts/1471950494.html/1628786353210-f42102b9-1eab-46c9-8a4d-31babc70b8f9.png" alt="image.png"></p>
<p>特点：</p>
<ul>
<li><ul>
<li><ul>
<li>可以在不同网段转发数据</li>
<li>隔绝广播域</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>网线直连、同轴电缆、集线器、网桥、交换机连接的设备必须在同一网段且处在同一广播域 </p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网名词</title>
    <url>/posts/521997408.html/</url>
    <content><![CDATA[<h1 id="网络、互联网、因特网"><a href="#网络、互联网、因特网" class="headerlink" title="网络、互联网、因特网"></a>网络、互联网、因特网</h1><p><img src="/posts/521997408.html/1629130821204-5705f111-60b9-4fc9-82f8-74878839f519.png" alt="image.png"></p>
<p>网络</p>
<p><img src="/posts/521997408.html/1629130829620-adf8d5c3-4541-4884-968c-2fb2858583ab.png" alt="image.png"></p>
<p>互联网</p>
<p>全球最大的互联网是：因特网；将全世界所有的计算机都连接在一起；一般使用大写I开头的Ineternet特指因特网；日常生活中说的：你的电脑上不了网。其实就是指：你的电脑没有连接到因特网 </p>
<h1 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h1><p>ISP，Internet Service Provider，Internet服务提供商，比如移动、电信、网通、铁通等 </p>
<p>我们平时拉的宽带都是通过ISP连接到Internet的</p>
<p><img src="/posts/521997408.html/1629131061785-03d9188e-5568-40b2-a038-7a8633c48443.png" alt="image.png"></p>
<h2 id="服务器机房"><a href="#服务器机房" class="headerlink" title="服务器机房"></a>服务器机房</h2><p><img src="/posts/521997408.html/1629131089550-ff68b2ca-bb42-4455-9535-be7b9fe7e261.png" alt="image.png"><img src="/posts/521997408.html/1629131098174-ac927715-3dcd-4f36-ac69-dd981702ab5b.png" alt="image.png"></p>
<h1 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h1><p>按照网络的范围进行分类，可以分为：局域网、城域网、广域网等 </p>
<p><strong>局域网（Local Area Network, LAN）</strong></p>
<p>一般是范围在几百米到十几公里内的计算机所构成的计算机网络；常用于公司、家庭、学校、医院、机关、一幢大楼等；</p>
<p>局域网中使用最广泛的网络技术叫<strong>以太网（Ethernet）</strong></p>
<p>在电脑、手机上经常见到的一个英文；意思是无线局域网 </p>
<p><strong>城域网（Metropolitan Area Network，MAN）</strong></p>
<p>一般范围是数十公里到数百公里，可以覆盖一个城市</p>
<p><strong>广域网（Wide Area Network，WAN）</strong></p>
<p>一般范围是几百公里到几千公里，可以覆盖一个国家。通常都需要租用IPS线路</p>
<h1 id="常见的几种接口"><a href="#常见的几种接口" class="headerlink" title="常见的几种接口"></a>常见的几种接口</h1><p>FastEthernet 快速以太网接口（100M）</p>
<p>GigabitEthernet 千兆以太网接口</p>
<p>Serial 串行接口</p>
<h1 id="上网方式"><a href="#上网方式" class="headerlink" title="上网方式"></a>上网方式</h1><h2 id="电话线入户"><a href="#电话线入户" class="headerlink" title="电话线入户"></a>电话线入户</h2><p><img src="/posts/521997408.html/1629132959057-f86bd945-de25-4937-b280-55fd420eb388.png" alt="image.png"></p>
<p>这就是平时说的：ADSL电话拨号上网；非对称数字用户线路，提供上、下行不对称的传输带宽 </p>
<p>猫（Modem）,调制解调器，进行数字信号和模拟信号的转换 </p>
<h2 id="光纤入户"><a href="#光纤入户" class="headerlink" title="光纤入户"></a>光纤入户</h2><p><img src="/posts/521997408.html/1629133048356-d7b33702-466c-49fc-86be-cd16694e88ef.png" alt="image.png"></p>
<p>光猫（ Optical Modem）光调制解调器，进行数字信号和光信号的转换</p>
<h2 id="网线入户"><a href="#网线入户" class="headerlink" title="网线入户"></a>网线入户</h2><p><img src="/posts/521997408.html/1629133106103-5a1caf2b-2949-456a-af15-65efb3b17178.png" alt="image.png"></p>
<h1 id="家用无线路由器的逻辑结构"><a href="#家用无线路由器的逻辑结构" class="headerlink" title="家用无线路由器的逻辑结构"></a>家用无线路由器的逻辑结构</h1><p><img src="/posts/521997408.html/1629133136680-1cdf7a1a-8c87-4cd0-a6b9-80adf5909aa3.png" alt="image.png"></p>
<h1 id="公网IP-amp-私网IP"><a href="#公网IP-amp-私网IP" class="headerlink" title="公网IP&amp;私网IP"></a>公网IP&amp;私网IP</h1><p>公网IP（Public） </p>
<p>Internet上的路由器中只有到达公网的路由表，没有到达私网的路由表 </p>
<p>公网IP由因特网信息中心统一分配和管理</p>
<p>IPS需要向Inter NIC申请公网IP</p>
<p>私网IP（Private） </p>
<p>主要用于局域网。</p>
<p>下面是保留的私网网段 </p>
<p>A类：10.0.0.0/8，1个A类网络 </p>
<p>B类：172.16.0.0/16 ~ 172.31.0.0/16，16个B类网络 </p>
<p>C类：192.168.0.0/24 ~ 192.168.255.0/24，256个C类网络 </p>
<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>私网IP访问Internet需要进行NAT转换为公网IP；这一步可以由路由器来完成</p>
<h2 id="NAT特点"><a href="#NAT特点" class="headerlink" title="NAT特点"></a>NAT特点</h2><p>可以节约公网IP资源；</p>
<p>会隐藏内部真实IP</p>
<h2 id="NAT分类"><a href="#NAT分类" class="headerlink" title="NAT分类"></a>NAT分类</h2><p>静态转换；手动配置NAT；映射表 一对一转换</p>
<p>动态转换；定义外部地址池，动态随机转换；一对一转换</p>
<h2 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h2><p>多对一转换，最大程度节约公网IP资源；采用端口多路复用方式，通过端口号标识不同的数据流；目前应用最广泛的NAT实现方式 </p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/posts/3328524930.html/</url>
    <content><![CDATA[<h1 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h1><p>函数（方法）直接或间接调用自身。是一种常用的编程技巧 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//直接调用自身</span><br><span class="line">    int sum(int n)&#123;</span><br><span class="line">        if(n&lt;=1) &#123;return n;&#125;</span><br><span class="line">        return n+sum(n-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//间接调用</span><br><span class="line">    void a(int v)&#123;</span><br><span class="line">        if(v&lt;0)&#123;return;&#125;</span><br><span class="line">        b(--v);</span><br><span class="line">    &#125;</span><br><span class="line">    void b(int v)&#123;</span><br><span class="line">        a(--v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一个有趣的问题：</p>
<p>假设A在一个电影院，想知道自己坐在哪一排，但是前面人很多， </p>
<p>A 懒得数，于是问前一排的人 B【你坐在哪一排？】，只要把 B 的答案加一，就是 A 的排数。 </p>
<p>B 懒得数，于是问前一排的人 C【你坐在哪一排？】，只要把 C 的答案加一，就是 B 的排数。 </p>
<p>C 懒得数，于是问前一排的人 D【你坐在哪一排？】，只要把 D 的答案加一，就是 C 的排数。 …… </p>
<p>直到问到最前面的一排，最后大家都知道自己在哪一排了 </p>
<h1 id="函数调用的过程"><a href="#函数调用的过程" class="headerlink" title="函数调用的过程"></a>函数调用的过程</h1><p>首先，我们要明确一件事情就是，一个函数如果没有执行完成，它就会一直占用内存。</p>
<p><img src="/posts/3328524930.html/1628788869623-edd44e8a-3211-434a-97f9-55ad568579bc.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test1(10);</span><br><span class="line">        test2(20);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void test1(int v)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static void test2(int v)&#123;</span><br><span class="line">        test3(30);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void test3(int v)&#123;&#125;  </span><br><span class="line">/*</span><br><span class="line">先从main函数进入（main进栈），在执行test1函数（test1进栈），test1函数执行完毕之后（test1出栈），执行test2函数（test2进栈），执行test3函数（test3进栈）；</span><br><span class="line">test3函数执行完毕（test3出栈），test2函数执行完毕（test2出栈），main函数执行结束（main出栈）</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<h3 id="函数的递归调用过程"><a href="#函数的递归调用过程" class="headerlink" title="函数的递归调用过程"></a>函数的递归调用过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main( String[ ] args) &#123;</span><br><span class="line">    sum( 4);</span><br><span class="line">&#125;</span><br><span class="line">private static int sum( int n) &#123;</span><br><span class="line">    if (n &lt;= 1) &#123;return n;&#125;</span><br><span class="line">    return n + sum(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果递归调用没有终止，将会一直消耗栈空间 最终导致栈内存溢出（Stack Overflow）</p>
<p>所以必需要有一个明确的结束递归的条件 也叫作<strong>边界条件、递归基</strong> </p>
<p><strong><img src="/posts/3328524930.html/1628789779769-d8900555-3eea-4f3c-bf51-12b76d1f15d9.png" alt="image.png"><img src="/posts/3328524930.html/1628789798965-7cfedcfa-c78e-4b4e-9378-3d3434efb8d5.png" alt="image.png"></strong>  </p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><ul>
<li>求 1+2+3+…+(n-1)+n 的和（n&gt;0）</li>
</ul>
<p>下面是三种解题方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//递归方法</span><br><span class="line">int sum(int n) &#123;</span><br><span class="line">    if (n &lt;= 1) return n;</span><br><span class="line">    return n + sum(n - 1);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">时间复杂度O(n)</span><br><span class="line">空间复杂度O(n)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//循环加法</span><br><span class="line">int sum(int n) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">    result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">时间复杂度O(n)</span><br><span class="line">空间复杂度O(1)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//数学公式</span><br><span class="line">int sum(int n)&#123;</span><br><span class="line">    if (n &lt;= 1) return n;</span><br><span class="line">    return ( 1 +n)* n &gt;&gt;1;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">时间复杂度O(1)</span><br><span class="line">空间复杂度O(1)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>注意：使用递归不是为了求得最优解，是为了简化解决问题的思路，代码会更加简洁 递归求出来的很有可能不是最优解，也有可能是最优解</strong> </p>
<h1 id="递归的基本思想"><a href="#递归的基本思想" class="headerlink" title="递归的基本思想"></a>递归的基本思想</h1><p>拆解问题：</p>
<p>把规模大的问题变成规模较小的同类型问题 </p>
<p>规模较小的问题又不断变成规模更小的问题 </p>
<p>规模小到一定程度可以直接得出它的解</p>
<p>求解：</p>
<p>由最小规模问题的解得出较大规模问题的解 </p>
<p>由较大规模问题的解不断得出规模更大问题的解 </p>
<p>最后得出原来问题的解 </p>
<p>凡是可以利用上述思想解决问题的，都可以尝试使用递归 很多链表、二叉树相关的问题都可以使用递归来解决 因为链表、二叉树本身就是递归的结构（链表中包含链表，二叉树中包含二叉树）</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>明确函数的功能</p>
<p>先不要去思考里面代码怎么写，首先搞清楚这个函数的干嘛用的，能完成什么功能？</p>
<p>明确原问题与子问题的关系 </p>
<p>寻找 f(n) 与 f(n – 1) 的关系</p>
<p>明确递归基（边界条件）</p>
<p>递归的过程中，子问题的规模在不断减小，当小到一定程度时可以直接得出它的解 </p>
<p>寻找递归基，相当于是思考：问题规模小到什么程度可以直接得出解？</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列：1、1、2、3、5、8、13、21、34、…… </p>
<p>F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n≥3） </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int fib(int n)&#123;</span><br><span class="line">    if(n&lt;=2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fib(n-1)+fib(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据递推式 T n= T n − 1+ T(n − 2) + O(1)，可得知时间复杂度：O（2n) </p>
<p>空间复杂度：O(n) </p>
<p>递归调用的空间复杂度 = 递归深度 * 每次调用所需的辅助空间</p>
<h3 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h3><p><img src="/posts/3328524930.html/1628874285887-4dc97de3-ccf9-4ec7-96a5-328c2627a32d.png" alt="image.png"></p>
<p>出现了特别多的重复计算 </p>
<p>这是一种“自顶向下”的调用过程 </p>
<h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>我们也看到了，在函数调用的过程中，出现了很多的重复调用和计算，我们利用数组来储存已经计算好的<strong>斐波那契数。</strong></p>
<p><strong><img src="/posts/3328524930.html/1628874870864-574b2aee-bba8-44e1-ba47-c7c10dcca3bb.png" alt="image.png"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int fib(int n)&#123;</span><br><span class="line">    if(n&lt;=2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int [] array=new int[n+1];</span><br><span class="line">    array[2]=array[1]=1;</span><br><span class="line">    return fib(array,n);</span><br><span class="line">&#125;</span><br><span class="line">public int fib(int[] array,int n)&#123;</span><br><span class="line">    if(array[n]==0)&#123;</span><br><span class="line">        array[n]=fib(array,n-1)+fib(array,n-2);</span><br><span class="line">    &#125;</span><br><span class="line">    return array[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>递归是一种比较浪费空间的一种操作，我们舍弃递归调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int fib(int n)&#123;</span><br><span class="line">    if(n&lt;=2)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int [] array=new int[n+1];</span><br><span class="line">    array[2]=array[1]=1;</span><br><span class="line">    for (int i=3;i&lt;=n;i++)&#123;</span><br><span class="line">        array[i]=array[i-1]+array[i-2];</span><br><span class="line">    &#125;</span><br><span class="line">    return array[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，空间复杂度：O(n) </p>
<p>这是一种“自底向上”的计算过程 </p>
<h3 id="优化3"><a href="#优化3" class="headerlink" title="优化3"></a>优化3</h3><p>由于每次运算只需要用到数组中的 2 个元素，所以可以使用<strong>滚动数组</strong>来优化 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int fib(int n) &#123;</span><br><span class="line">    if (n &lt;= 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] array=new int[2];</span><br><span class="line">    array[0]=array[1]=1;</span><br><span class="line">    for (int i=3;i&lt;=n;i++)&#123;</span><br><span class="line">        array[i%2]=array[(i-1)%2]+array[(i-2)%2];</span><br><span class="line">    &#125;</span><br><span class="line">    return array[n%2];</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，空间复杂度：O(1) </p>
<h3 id="优化4"><a href="#优化4" class="headerlink" title="优化4"></a>优化4</h3><p>乘、除、模运算效率较低，建议用其他方式取代 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int fib(int n) &#123;</span><br><span class="line">    if (n &lt;= 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] array=new int[2];</span><br><span class="line">    array[0]=array[1]=1;</span><br><span class="line">    for (int i=3;i&lt;=n;i++)&#123;</span><br><span class="line">        array[i&amp;1]=array[(i-1)&amp;1]+array[(i-2)&amp;1];</span><br><span class="line">    &#125;</span><br><span class="line">    return array[n&amp;1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化5"><a href="#优化5" class="headerlink" title="优化5"></a>优化5</h3><p>滚动数组其实就是两个变量，我们不在采用数组的方式，使用变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int fib(int n) &#123;</span><br><span class="line">    if (n &lt;= 2)return 1;</span><br><span class="line">    int first = 1;</span><br><span class="line">    int second = 1;</span><br><span class="line">    for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">        second = first + second;</span><br><span class="line">        first = second - first;</span><br><span class="line">    &#125;</span><br><span class="line">    return second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，空间复杂度：O(1) </p>
<h3 id="优化6"><a href="#优化6" class="headerlink" title="优化6"></a>优化6</h3><p><img src="/posts/3328524930.html/1628875850125-82fc7999-d95f-473c-a8aa-d9090ee071a6.png" alt="image.png"></p>
<h2 id="走楼梯"><a href="#走楼梯" class="headerlink" title="走楼梯"></a>走楼梯</h2><p>楼梯有 n 阶台阶，上楼可以一步上 1 阶，也可以一步上 2 阶，走完 n 阶台阶共有多少种不同的走法？ </p>
<p>假设 n 阶台阶有 f(n) 种走法，第 1 步有 2 种走法 </p>
<p>如果上 1 阶，那就还剩 n – 1 阶，共 f(n – 1) 种走法 </p>
<p>如果上 2 阶，那就还剩 n – 2 阶，共 f(n – 2) 种走法 </p>
<p>所以 f(n) = f(n – 1) + f(n – 2) </p>
<p><img src="/posts/3328524930.html/1628965789579-7ffec679-4f32-4288-b8ec-93f5645b6fed.png" alt="image.png"></p>
<p><img src="/posts/3328524930.html/1628965803269-202c3951-ee31-495d-a892-06379a0e6400.png" alt="image.png"></p>
<p>优化思路也是一至</p>
<p><img src="/posts/3328524930.html/1628965826765-6f0bb89e-9f70-4392-bb55-5adc1818b37c.png" alt="image.png"></p>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>编程实现把 A 的 n 个盘子移动到 C（盘子编号是 [1, n] ） </p>
<p>每次只能移动1个盘子 </p>
<p>大盘子只能放在小盘子下面 </p>
<p><img src="/posts/3328524930.html/1628965917642-e0d35724-409d-4897-a037-5172991a4be6.png" alt="image.png"></p>
<p>一个盘子</p>
<p><img src="/posts/3328524930.html/1628965937579-2c6570d5-dfc2-49b9-b84e-8d7c02ec390a.png" alt="image.png"></p>
<p>两个盘子</p>
<p><img src="/posts/3328524930.html/1628965967902-e4ca6503-ce20-4cc2-b2d1-3e642aba7ec7.png" alt="image.png"></p>
<p>三个盘子</p>
<p><img src="/posts/3328524930.html/1628965987202-b3db545c-7b1a-4572-bee9-e1e6846173c8.png" alt="image.png"></p>
<p><img src="/posts/3328524930.html/1628965997109-2c5cfb3d-b896-47df-aa73-2134c6b6ddc0.png" alt="image.png"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>其实分 2 种情况讨论即可</p>
<p>当 n == 1时，直接将盘子从 A 移动到 C</p>
<p>当 n &gt; 1时，可以拆分成3大步骤</p>
<p>① 将 n – 1 个盘子从 A 移动到 B</p>
<p>② 将编号为 n 的盘子从 A 移动到 C</p>
<p>③ 将 n – 1 个盘子从 B 移动到 C</p>
<p>步骤 ① ③ 明显是个递归调用</p>
<p><img src="/posts/3328524930.html/1628966043628-3956bf94-7716-4c79-8667-cd7025a8343c.png" alt="image.png"></p>
<p><img src="/posts/3328524930.html/1628966052035-0b2b1792-1cae-4712-b8f3-5e6317d1b660.png" alt="image.png"></p>
<p><em><strong>实现：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void hanoi(int n, String p1, String p2, String p3) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        move(n, p1, p3);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    hanoi(n - 1, p1, p3, p2);</span><br><span class="line">    move(n, p1, p3);</span><br><span class="line">    hanoi(n - 1, p2, p1, p3);</span><br><span class="line">&#125; </span><br><span class="line">void move(int no, String from, String to) &#123;</span><br><span class="line">    System.out.println(&quot;将&quot; + no + &quot;号盘子从&quot; + from + &quot;移动到&quot; + to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Tn= 2 ∗ Tn − 1+ O(1) 因此时间复杂度是：O（2n）;空间复杂度：O(n)</p>
<h1 id="递归转非递归"><a href="#递归转非递归" class="headerlink" title="递归转非递归"></a>递归转非递归</h1><p>递归转非递归的万能方法：自己维护一个栈，来保存参数、局部变量；但是空间复杂度依然没有得到优化</p>
<p><img src="/posts/3328524930.html/1629045920396-4467ece0-1a25-4e6c-92fe-cc7088255d2c.png" alt="image.png"><img src="/posts/3328524930.html/1629045923474-960f12a2-579c-4ae4-88f5-be05048caa68.png" alt="image.png"></p>
<p>在某些时候，也可以重复使用一组相同的变量来保存每个栈帧的内容 </p>
<p><img src="/posts/3328524930.html/1629045940624-b60602b9-b5a9-4ebe-910a-30b6e7d95604.png" alt="image.png"></p>
<p>这里重复使用变量 i 保存原来栈帧中的参数；空间复杂度从 O n    降到了 O 1 </p>
<h1 id="尾调用（多看）"><a href="#尾调用（多看）" class="headerlink" title="尾调用（多看）"></a>尾调用（多看）</h1><p>一个函数的最后一个动作是调用函数；如果最后一个动作是调用自身，称为尾递归（Tail Recursion），是尾调用的特殊情况</p>
<p><img src="/posts/3328524930.html/1629046027637-d22dad77-a360-4102-8bde-79a062a3889e.png" alt="image.png"><img src="/posts/3328524930.html/1629046030815-b09092ef-ab4f-451f-b7df-31584ed13826.png" alt="image.png"></p>
<p>一些编译器能对尾调用进行优化，以达到节省栈空间的目的 </p>
<p><img src="/posts/3328524930.html/1629046134846-0ed1e07c-a095-4915-8194-2a5dd7f180cf.png" alt="image.png"></p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用优化也叫做尾调用消除（Tail Call Elimination）</p>
<p>如果当前栈帧上的局部变量等内容都不需要用了，当前栈帧经过适当的改变后可以直接当作被尾调用的函数的栈帧；</p>
<p>使用，然后程序可以 jump 到被尾调用的函数代码 </p>
<p>生成栈帧改变代码与 jump 的过程称作尾调用消除或尾调用优化 </p>
<p>尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高</p>
<p>消除尾递归里的尾调用比消除一般的尾调用容易很多 </p>
<p>比如Java虚拟机（JVM）会消除尾递归里的尾调用，但不会消除一般的尾调用（因为改变不了栈帧） </p>
<p>因此尾递归优化相对比较普遍，平时的递归代码可以考虑尽量使用尾递归的形式</p>
<h2 id="尾递归示例"><a href="#尾递归示例" class="headerlink" title="尾递归示例"></a>尾递归示例</h2><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p><img src="/posts/3328524930.html/1629046303622-39b5c4b2-ba04-41d6-93b8-6125dcb1e7c7.png" alt="image.png"></p>
<p>优化后</p>
<p><img src="/posts/3328524930.html/1629046315546-0504c66c-c4cf-4574-8295-d938e107b7bc.png" alt="image.png"></p>
<h3 id="斐波那契数列-1"><a href="#斐波那契数列-1" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><img src="/posts/3328524930.html/1629046330819-5a36b781-a5d0-4783-b2cc-65ed1e1f5685.png" alt="image.png"></p>
<p>优化后</p>
<p><img src="/posts/3328524930.html/1629046337921-a8826fbe-448b-497f-91cd-dc25c829ae73.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
